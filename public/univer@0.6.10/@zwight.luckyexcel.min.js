/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/@zwight/luckyexcel@1.1.4/dist/luckyexcel.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? (module.exports = t(
        require('nanoid'),
        require('dayjs'),
        require('@univerjs/core'),
        require('@progress/jszip-esm'),
        require('@zwight/exceljs'),
        require('papaparse'),
      ))
    : 'function' == typeof define && define.amd
    ? define(
        [
          'nanoid',
          'dayjs',
          '@univerjs/core',
          '@progress/jszip-esm',
          '@zwight/exceljs',
          'papaparse',
        ],
        t,
      )
    : ((e = 'undefined' != typeof globalThis ? globalThis : e || self).LuckyExcel = t(
        e.nanoid,
        e.dayjs,
        e.core,
        e.JSZip,
        e.exceljs,
        e.Papa,
      ));
})(this, function (e, t, l, n, r, i) {
  'use strict';
  function a(e) {
    return e && 'object' == typeof e && 'default' in e ? e : { default: e };
  }
  var s = a(t),
    o = a(n),
    c = a(r),
    u = a(i);
  const h = [
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
    ],
    f = {
      A: 0,
      B: 1,
      C: 2,
      D: 3,
      E: 4,
      F: 5,
      G: 6,
      H: 7,
      I: 8,
      J: 9,
      K: 10,
      L: 11,
      M: 12,
      N: 13,
      O: 14,
      P: 15,
      Q: 16,
      R: 17,
      S: 18,
      T: 19,
      U: 20,
      V: 21,
      W: 22,
      X: 23,
      Y: 24,
      Z: 25,
    },
    g = 'docProps/core.xml',
    d = 'docProps/app.xml',
    m = 'xl/workbook.xml',
    p = 'xl/styles.xml',
    E = 'inlineStr',
    b = 's',
    T = 'str';
  let y = {
    0: 'General',
    1: '0',
    2: '0.00',
    3: '#,##0',
    4: '#,##0.00',
    9: '0%',
    10: '0.00%',
    11: '0.00E+00',
    12: '# ?/?',
    13: '# ??/??',
    14: 'm/d/yy',
    15: 'd-mmm-yy',
    16: 'd-mmm',
    17: 'mmm-yy',
    18: 'h:mm AM/PM',
    19: 'h:mm:ss AM/PM',
    20: 'h:mm',
    21: 'h:mm:ss',
    22: 'm/d/yy h:mm',
    37: '#,##0 ;(#,##0)',
    38: '#,##0 ;[Red](#,##0)',
    39: '#,##0.00;(#,##0.00)',
    40: '#,##0.00;[Red](#,##0.00)',
    45: 'mm:ss',
    46: '[h]:mm:ss',
    47: 'mmss.0',
    48: '##0.0E+0',
    49: '@',
  };
  const v = {
      0: '00000000',
      1: '00FFFFFF',
      2: '00FF0000',
      3: '0000FF00',
      4: '000000FF',
      5: '00FFFF00',
      6: '00FF00FF',
      7: '0000FFFF',
      8: '00000000',
      9: '00FFFFFF',
      10: '00FF0000',
      11: '0000FF00',
      12: '000000FF',
      13: '00FFFF00',
      14: '00FF00FF',
      15: '0000FFFF',
      16: '00800000',
      17: '00008000',
      18: '00000080',
      19: '00808000',
      20: '00800080',
      21: '00008080',
      22: '00C0C0C0',
      23: '00808080',
      24: '009999FF',
      25: '00993366',
      26: '00FFFFCC',
      27: '00CCFFFF',
      28: '00660066',
      29: '00FF8080',
      30: '000066CC',
      31: '00CCCCFF',
      32: '00000080',
      33: '00FF00FF',
      34: '00FFFF00',
      35: '0000FFFF',
      36: '00800080',
      37: '00800000',
      38: '00008080',
      39: '000000FF',
      40: '0000CCFF',
      41: '00CCFFFF',
      42: '00CCFFCC',
      43: '00FFFF99',
      44: '0099CCFF',
      45: '00FF99CC',
      46: '00CC99FF',
      47: '00FFCC99',
      48: '003366FF',
      49: '0033CCCC',
      50: '0099CC00',
      51: '00FFCC00',
      52: '00FF9900',
      53: '00FF6600',
      54: '00666699',
      55: '00969696',
      56: '00003366',
      57: '00339966',
      58: '00003300',
      59: '00333300',
      60: '00993300',
      61: '00993366',
      62: '00333399',
      63: '00333333',
      64: null,
      65: null,
    },
    w = {
      none: 0,
      thin: 1,
      hair: 2,
      dotted: 3,
      dashed: 4,
      dashDot: 5,
      dashDotDot: 6,
      double: 7,
      medium: 8,
      mediumDashed: 9,
      mediumDashDot: 10,
      mediumDashDotDot: 11,
      slantDashDot: 12,
      thick: 13,
    };
  let I = {
    'yyyy/m/d;@': 'yyyy/MM/dd',
    'yyyy&quot;年&quot;m&quot;月&quot;d&quot;日&quot;;@':
      'yyyy&quot;年&quot;MM&quot;月&quot;dd&quot;日&quot;',
    '[$-409]yyyy/m/d\\ h:mm\\ AM/PM;@': 'yyyy/MM/dd hh:mm AM/PM',
  };
  const C = { 0: 'defualt', 1: 'Roman', 2: 'Swiss', 3: 'Modern', 4: 'Script', 5: 'Decorative' },
    R = {
      list: 'dropdown',
      whole: 'number_integer',
      decimal: 'number_decimal',
      custom: 'text_content',
      textLength: 'text_length',
      date: 'date',
      unknown1: 'number',
      unknown2: 'checkbox',
      unknown3: 'validity',
    },
    L = ['number', 'number_integer', 'number_decimal', 'text_length'],
    S = {
      common: {
        between: 'bw',
        notBetween: 'nb',
        equal: 'eq',
        notEqualTo: 'ne',
        moreThanThe: 'gt',
        lessThan: 'lt',
        greaterOrEqualTo: 'gte',
        lessThanOrEqualTo: 'lte',
      },
      text_content: { include: 'include', exclude: 'exclude', equal: 'equal' },
      date: {
        between: 'bw',
        notBetween: 'nb',
        equal: 'eq',
        notEqualTo: 'ne',
        earlierThan: 'bf',
        noEarlierThan: 'nbf',
        laterThan: 'af',
        noLaterThan: 'naf',
      },
      validity: { card: 'card', phone: 'phone' },
    };
  var x, N, O;
  function M(e) {
    let t = e.split('!'),
      l = '';
    if ((t.length > 1 ? (t[0], (l = t[1])) : (l = t[0]), -1 == l.indexOf(':'))) {
      let e = parseInt(l.replace(/[^0-9]/g, '')) - 1,
        t = A(l.replace(/[^A-Za-z]/g, ''));
      return isNaN(e) || isNaN(t) ? null : { row: [e, e], column: [t, t] };
    }
    {
      let e = l.split(':'),
        t = [],
        n = [];
      return (
        (t[0] = parseInt(e[0].replace(/[^0-9]/g, '')) - 1),
        (t[1] = parseInt(e[1].replace(/[^0-9]/g, '')) - 1),
        t[0] > t[1]
          ? null
          : ((n[0] = A(e[0].replace(/[^A-Za-z]/g, ''))),
            (n[1] = A(e[1].replace(/[^A-Za-z]/g, ''))),
            n[0] > n[1] ? null : { row: t, column: n })
      );
    }
  }
  function A(e) {
    let t = (e = e.toUpperCase()).length;
    if (0 == t) return NaN;
    let l = e.split(''),
      n = h.length,
      r = 0;
    for (let e = t - 1; e >= 0; e--)
      r += e == t - 1 ? f[l[e]] : Math.pow(n, t - e - 1) * (f[l[e]] + 1);
    return r;
  }
  function F(e) {
    let t = h.length;
    if (e < t) return h[e];
    {
      let l = 0,
        n = '',
        r = 1,
        i = 0;
      for (; e >= (t / (t - 1)) * (Math.pow(t, r++) - 1); ) i = r;
      l = e - (t / (t - 1)) * (Math.pow(t, i - 1) - 1) + 1;
      for (let e = i; e > 0; e--) {
        let r = l;
        if (1 == e) return (r %= t), 0 == r && (r = 26), n + h[r - 1];
        (r = Math.ceil(r / Math.pow(t, e - 1))), (n += h[r - 1]), e > 1 && (l -= (r - 1) * t);
      }
    }
  }
  function B(e) {
    if (null == e) return 0;
    return (72 * (e / 914400)) / 0.75;
  }
  function P(e) {
    return 914400 * ((0.75 * e) / 72);
  }
  function k(e, t, l) {
    let n = e[t];
    return (n = null == n ? l : n), n;
  }
  function _(e) {
    return Math.round(8 * (e - 0.83) + 5);
  }
  function D(e) {
    return Math.round(e / 0.75);
  }
  function X(e, t) {
    let l = e.substring(e.length - 6, e.length),
      n = G('#' + l),
      r = (function (e, t, l) {
        (e /= 255), (t /= 255), (l /= 255);
        var n,
          r,
          i = Math.max(e, t, l),
          a = Math.min(e, t, l),
          s = (i + a) / 2;
        if (i == a) n = r = 0;
        else {
          var o = i - a;
          switch (((r = s > 0.5 ? o / (2 - i - a) : o / (i + a)), i)) {
            case e:
              n = (t - l) / o + (t < l ? 6 : 0);
              break;
            case t:
              n = (l - e) / o + 2;
              break;
            case l:
              n = (e - t) / o + 4;
          }
          n /= 6;
        }
        return [n, r, s];
      })(n[0], n[1], n[2]);
    if (t > 0) r[2] = r[2] * (1 - t) + t;
    else {
      if (!(t < 0)) return '#' + l;
      r[2] = r[2] * (1 + t);
    }
    return (function (e) {
      var t = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      if (/^(rgb|RGB)/.test(e)) {
        for (
          var l = e.replace(/(?:\(|\)|rgb|RGB)*/g, '').split(','), n = '#', r = 0;
          r < l.length;
          r++
        ) {
          var i = Number(l[r]).toString(16);
          i.length < 2 && (i = '0' + i), (n += i);
        }
        return 7 !== n.length && (n = e), n;
      }
      if (t.test(e)) {
        var a = e.replace(/#/, '').split('');
        if (6 === a.length) return e;
        if (3 === a.length) {
          var s = '#';
          for (r = 0; r < a.length; r += 1) s += a[r] + a[r];
          return s;
        }
      }
      return e;
    })(
      'RGB(' +
        (function (e, t, l) {
          var n, r, i;
          if (0 == t) n = r = i = l;
          else {
            var a = function (e, t, l) {
                return (
                  l < 0 && (l += 1),
                  l > 1 && (l -= 1),
                  l < 1 / 6
                    ? e + 6 * (t - e) * l
                    : l < 0.5
                    ? t
                    : l < 2 / 3
                    ? e + (t - e) * (2 / 3 - l) * 6
                    : e
                );
              },
              s = l < 0.5 ? l * (1 + t) : l + t - l * t,
              o = 2 * l - s;
            (n = a(o, s, e + 1 / 3)), (r = a(o, s, e)), (i = a(o, s, e - 1 / 3));
          }
          return [Math.round(255 * n), Math.round(255 * r), Math.round(255 * i)];
        })(r[0], r[1], r[2]).join(',') +
        ')',
    );
  }
  function G(e) {
    var t = e.toLowerCase();
    if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(t)) {
      if (4 === t.length) {
        for (var l = '#', n = 1; n < 4; n += 1) l += t.slice(n, n + 1).concat(t.slice(n, n + 1));
        t = l;
      }
      var r = [];
      for (n = 1; n < 7; n += 2) r.push(parseInt('0x' + t.slice(n, n + 2)));
      return r;
    }
    return null;
  }
  function V(e) {
    null == e && (e = 'Sheet');
    let t = navigator.userAgent.replace(/[^a-zA-Z0-9]/g, '').split(''),
      l = '';
    for (let e = 0; e < 5; e++) l += t[Math.round(Math.random() * (t.length - 1))];
    return e + '_' + l + '_' + new Date().getTime();
  }
  function W(e) {
    return null == e || 0 == e.length
      ? e
      : e
          .replace(/&amp;/g, '&')
          .replace(/&quot;/g, '"')
          .replace(/&#34;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&nbsp;/g, ' ')
          .replace(/&apos;/g, "'")
          .replace(/&iexcl;/g, '¡')
          .replace(/&cent;/g, '¢')
          .replace(/&pound;/g, '£')
          .replace(/&curren;/g, '¤')
          .replace(/&yen;/g, '¥')
          .replace(/&brvbar;/g, '¦')
          .replace(/&sect;/g, '§')
          .replace(/&uml;/g, '¨')
          .replace(/&copy;/g, '©')
          .replace(/&ordf;/g, 'ª')
          .replace(/&laquo;/g, '«')
          .replace(/&not;/g, '¬')
          .replace(/&shy;/g, '­')
          .replace(/&reg;/g, '®')
          .replace(/&macr;/g, '¯')
          .replace(/&deg;/g, '°')
          .replace(/&plusmn;/g, '±')
          .replace(/&sup2;/g, '²')
          .replace(/&sup3;/g, '³')
          .replace(/&acute;/g, '´')
          .replace(/&micro;/g, 'µ')
          .replace(/&para;/g, '¶')
          .replace(/&middot;/g, '·')
          .replace(/&cedil;/g, '¸')
          .replace(/&sup1;/g, '¹')
          .replace(/&ordm;/g, 'º')
          .replace(/&raquo;/g, '»')
          .replace(/&frac14;/g, '¼')
          .replace(/&frac12;/g, '½')
          .replace(/&frac34;/g, '¾')
          .replace(/&iquest;/g, '¿')
          .replace(/&times;/g, '×')
          .replace(/&divide;/g, '÷')
          .replace(/&Agrave;/g, 'À')
          .replace(/&Aacute;/g, 'Á')
          .replace(/&Acirc;/g, 'Â')
          .replace(/&Atilde;/g, 'Ã')
          .replace(/&Auml;/g, 'Ä')
          .replace(/&Aring;/g, 'Å')
          .replace(/&AElig;/g, 'Æ')
          .replace(/&Ccedil;/g, 'Ç')
          .replace(/&Egrave;/g, 'È')
          .replace(/&Eacute;/g, 'É')
          .replace(/&Ecirc;/g, 'Ê')
          .replace(/&Euml;/g, 'Ë')
          .replace(/&Igrave;/g, 'Ì')
          .replace(/&Iacute;/g, 'Í')
          .replace(/&Icirc;/g, 'Î')
          .replace(/&Iuml;/g, 'Ï')
          .replace(/&ETH;/g, 'Ð')
          .replace(/&Ntilde;/g, 'Ñ')
          .replace(/&Ograve;/g, 'Ò')
          .replace(/&Oacute;/g, 'Ó')
          .replace(/&Ocirc;/g, 'Ô')
          .replace(/&Otilde;/g, 'Õ')
          .replace(/&Ouml;/g, 'Ö')
          .replace(/&Oslash;/g, 'Ø')
          .replace(/&Ugrave;/g, 'Ù')
          .replace(/&Uacute;/g, 'Ú')
          .replace(/&Ucirc;/g, 'Û')
          .replace(/&Uuml;/g, 'Ü')
          .replace(/&Yacute;/g, 'Ý')
          .replace(/&THORN;/g, 'Þ')
          .replace(/&szlig;/g, 'ß')
          .replace(/&agrave;/g, 'à')
          .replace(/&aacute;/g, 'á')
          .replace(/&acirc;/g, 'â')
          .replace(/&atilde;/g, 'ã')
          .replace(/&auml;/g, 'ä')
          .replace(/&aring;/g, 'å')
          .replace(/&aelig;/g, 'æ')
          .replace(/&ccedil;/g, 'ç')
          .replace(/&egrave;/g, 'è')
          .replace(/&eacute;/g, 'é')
          .replace(/&ecirc;/g, 'ê')
          .replace(/&euml;/g, 'ë')
          .replace(/&igrave;/g, 'ì')
          .replace(/&iacute;/g, 'í')
          .replace(/&icirc;/g, 'î')
          .replace(/&iuml;/g, 'ï')
          .replace(/&eth;/g, 'ð')
          .replace(/&ntilde;/g, 'ñ')
          .replace(/&ograve;/g, 'ò')
          .replace(/&oacute;/g, 'ó')
          .replace(/&ocirc;/g, 'ô')
          .replace(/&otilde;/g, 'õ')
          .replace(/&ouml;/g, 'ö')
          .replace(/&oslash;/g, 'ø')
          .replace(/&ugrave;/g, 'ù')
          .replace(/&uacute;/g, 'ú')
          .replace(/&ucirc;/g, 'û')
          .replace(/&uuml;/g, 'ü')
          .replace(/&yacute;/g, 'ý')
          .replace(/&thorn;/g, 'þ')
          .replace(/&yuml;/g, 'ÿ');
  }
  !(function (e) {
    (e[(e.Stack = 1073741824)] = 'Stack'),
      (e[(e.PercentStack = 1610612736)] = 'PercentStack'),
      (e[(e.Horizontal = 268435456)] = 'Horizontal');
  })(x || (x = {})),
    (function (e) {
      (e[(e.None = 0)] = 'None'),
        (e[(e.Line = 2)] = 'Line'),
        (e[(e.Column = 4)] = 'Column'),
        (e[(e.ColumnStacked = 1073741828)] = 'ColumnStacked'),
        (e[(e.ColumnPercentStacked = 1610612740)] = 'ColumnPercentStacked'),
        (e[(e.Bar = 268435460)] = 'Bar'),
        (e[(e.BarStacked = 1342177284)] = 'BarStacked'),
        (e[(e.BarPercentStacked = 1879048196)] = 'BarPercentStacked'),
        (e[(e.Pie = 8)] = 'Pie'),
        (e[(e.Doughnut = 264)] = 'Doughnut'),
        (e[(e.Area = 16)] = 'Area'),
        (e[(e.AreaStacked = 1073741840)] = 'AreaStacked'),
        (e[(e.AreaPercentStacked = 1610612752)] = 'AreaPercentStacked'),
        (e[(e.Radar = 32)] = 'Radar'),
        (e[(e.Scatter = 64)] = 'Scatter'),
        (e[(e.Combination = 128)] = 'Combination');
    })(N || (N = {})),
    (function (e) {
      (e[(e.Empty = 0)] = 'Empty'),
        (e[(e.CategoryName = 2)] = 'CategoryName'),
        (e[(e.SeriesName = 4)] = 'SeriesName'),
        (e[(e.Value = 8)] = 'Value'),
        (e[(e.Percentage = 16)] = 'Percentage');
    })(O || (O = {}));
  class H {
    static trim(e) {
      return null == e && (e = ''), e.replace(/(^\s*)|(\s*$)/g, '');
    }
    static functionCopy(e, t, l) {
      let n = this;
      if (null == n.operatorjson) {
        let e = n.operator.split('|'),
          t = {};
        for (let l = 0; l < e.length; l++) t[e[l].toString()] = 1;
        n.operatorjson = t;
      }
      null == t && (t = 'down'), null == l && (l = 1), '=' == e.substr(0, 1) && (e = e.substr(1));
      let r = e.split(''),
        i = 0,
        a = '',
        s = '',
        o = { bracket: 0, comma: 0, squote: 0, dquote: 0 };
      for (; i < r.length; ) {
        let e = r[i];
        if ('(' == e && 0 == o.dquote)
          (o.bracket += 1), a.length > 0 ? (s += a + '(') : (s += '('), (a = '');
        else if (')' == e && 0 == o.dquote)
          (o.bracket -= 1), (s += n.functionCopy(a, t, l) + ')'), (a = '');
        else if ('"' == e && 0 == o.squote)
          o.dquote > 0
            ? ((s += a + '"'), (o.dquote -= 1), (a = ''))
            : ((o.dquote += 1), (a += '"'));
        else if (',' == e && 0 == o.dquote) (s += n.functionCopy(a, t, l) + ','), (a = '');
        else if ('&' == e && 0 == o.dquote)
          a.length > 0 ? ((s += n.functionCopy(a, t, l) + '&'), (a = '')) : (s += '&');
        else if (e in n.operatorjson && 0 == o.dquote) {
          let o = '';
          i + 1 < r.length && (o = r[i + 1]);
          let c = i - 1,
            u = null;
          if (c >= 0)
            do {
              u = r[c--];
            } while (c >= 0 && ' ' == u);
          e + o in n.operatorjson
            ? (a.length > 0 ? ((s += n.functionCopy(a, t, l) + e + o), (a = '')) : (s += e + o),
              i++)
            : /[^0-9]/.test(o) ||
              '-' != e ||
              ('(' != u && null != u && ',' != u && ' ' != u && !(u in n.operatorjson))
            ? a.length > 0
              ? ((s += n.functionCopy(a, t, l) + e), (a = ''))
              : (s += e)
            : (a += e);
        } else a += e;
        i == r.length - 1 &&
          (n.iscelldata(n.trim(a))
            ? 'down' == t
              ? (s += n.downparam(n.trim(a), l))
              : 'up' == t
              ? (s += n.upparam(n.trim(a), l))
              : 'left' == t
              ? (s += n.leftparam(n.trim(a), l))
              : 'right' == t && (s += n.rightparam(n.trim(a), l))
            : (s += n.trim(a))),
          i++;
      }
      return s;
    }
    static downparam(e, t) {
      return this.updateparam('d', e, t);
    }
    static upparam(e, t) {
      return this.updateparam('u', e, t);
    }
    static leftparam(e, t) {
      return this.updateparam('l', e, t);
    }
    static rightparam(e, t) {
      return this.updateparam('r', e, t);
    }
    static updateparam(e, t, l) {
      let n,
        r = this,
        i = t.split('!'),
        a = '';
      if ((i.length > 1 ? ((n = i[1]), (a = i[0] + '!')) : (n = i[0]), -1 == n.indexOf(':'))) {
        let i = parseInt(n.replace(/[^0-9]/g, '')),
          s = A(n.replace(/[^A-Za-z]/g, '')),
          o = J(n),
          c = o[0] ? '$' : '',
          u = o[1] ? '$' : '';
        return (
          'u' != e || o[0]
            ? 'r' != e || o[1]
              ? 'l' != e || o[1]
                ? o[0] || (i += l)
                : (s -= l)
              : (s += l)
            : (i -= l),
          i < 0 || s < 0
            ? r.error.r
            : isNaN(i) || isNaN(s)
            ? isNaN(i)
              ? isNaN(s)
                ? t
                : a + u + F(s)
              : a + c + i
            : a + u + F(s) + c + i
        );
      }
      {
        n = n.split(':');
        let i = [],
          s = [];
        if (
          ((i[0] = parseInt(n[0].replace(/[^0-9]/g, ''))),
          (i[1] = parseInt(n[1].replace(/[^0-9]/g, ''))),
          i[0] > i[1])
        )
          return t;
        if (
          ((s[0] = A(n[0].replace(/[^A-Za-z]/g, ''))),
          (s[1] = A(n[1].replace(/[^A-Za-z]/g, ''))),
          s[0] > s[1])
        )
          return t;
        let o = J(n[0]),
          c = J(n[1]),
          u = o[0] ? '$' : '',
          h = o[1] ? '$' : '',
          f = c[0] ? '$' : '',
          g = c[1] ? '$' : '';
        return (
          'u' == e
            ? (o[0] || (i[0] -= l), c[0] || (i[1] -= l))
            : 'r' == e
            ? (o[1] || (s[0] += l), c[1] || (s[1] += l))
            : 'l' == e
            ? (o[1] || (s[0] -= l), c[1] || (s[1] -= l))
            : (o[0] || (i[0] += l), c[0] || (i[1] += l)),
          i[0] < 0 || s[0] < 0
            ? r.error.r
            : isNaN(s[0]) && isNaN(s[1])
            ? a + u + i[0] + ':' + f + i[1]
            : isNaN(i[0]) && isNaN(i[1])
            ? a + h + F(s[0]) + ':' + g + F(s[1])
            : a + h + F(s[0]) + u + i[0] + ':' + g + F(s[1]) + f + i[1]
        );
      }
    }
    static iscelldata(e) {
      let t,
        l = e.split('!');
      t = l.length > 1 ? l[1] : l[0];
      let n = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g,
        r =
          /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g;
      if (-1 == t.indexOf(':')) {
        let e = parseInt(t.replace(/[^0-9]/g, '')) - 1,
          l = A(t.replace(/[^A-Za-z]/g, ''));
        return !(isNaN(e) || isNaN(l) || !t.toString().match(n)) || (!!isNaN(e) && (isNaN(l), !1));
      }
      {
        (r =
          /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g),
          (t = t.split(':'));
        let e = [],
          l = [];
        return (
          (e[0] = parseInt(t[0].replace(/[^0-9]/g, '')) - 1),
          (e[1] = parseInt(t[1].replace(/[^0-9]/g, '')) - 1),
          e[0] > e[1]
            ? !1
            : ((l[0] = A(t[0].replace(/[^A-Za-z]/g, ''))),
              (l[1] = A(t[1].replace(/[^A-Za-z]/g, ''))),
              !(l[0] > l[1]) && !(!t[0].toString().match(r) || !t[1].toString().match(r)))
        );
      }
    }
  }
  function z(e) {
    return !/[^\u0800-\u4e00]/.test(e);
  }
  function q(e, t) {
    let l, n, r;
    t || (t = {});
    let i = function () {
      try {
        return new window.XMLHttpRequest();
      } catch (e) {}
    };
    var a =
      'undefined' != typeof window && window.ActiveXObject
        ? function () {
            return (
              i() ||
              (function () {
                try {
                  return new window.ActiveXObject('Microsoft.XMLHTTP');
                } catch (e) {}
              })()
            );
          }
        : i;
    'function' == typeof t
      ? ((r = t), (t = {}))
      : 'function' == typeof t.callback && (r = t.callback),
      (l = function (e) {
        r(null, e);
      }),
      (n = function (e) {
        r(e, null);
      });
    try {
      var s = a();
      s.open('GET', e, !0),
        'responseType' in s && (s.responseType = 'arraybuffer'),
        s.overrideMimeType && s.overrideMimeType('text/plain; charset=x-user-defined'),
        (s.onreadystatechange = function (t) {
          if (4 === s.readyState)
            if (200 === s.status || 0 === s.status)
              try {
                l(
                  (function (e) {
                    return e.response || e.responseText;
                  })(s),
                );
              } catch (e) {
                n(new Error(e));
              }
            else n(new Error('Ajax error for ' + e + ' : ' + this.status + ' ' + this.statusText));
        }),
        t.progress &&
          (s.onprogress = function (l) {
            t.progress({
              path: e,
              originalEvent: l,
              percent: (l.loaded / l.total) * 100,
              loaded: l.loaded,
              total: l.total,
            });
          }),
        s.send();
    } catch (e) {
      n(new Error(e));
    }
  }
  function U(e) {
    if (!e || e?.length <= 0) return [];
    let t = (function (e) {
        e?.map((t) => {
          if (t.includes(':')) {
            let l = t.split(':');
            2 === l?.length &&
              (e = e.concat(
                (function (e) {
                  let t = [];
                  const l = new RegExp(/[A-Z]+|[0-9]+/g),
                    n = e[0]?.match(l),
                    r = e[1]?.match(l),
                    i = Math.max(A(n[0]), A(r[0])),
                    a = Math.min(A(n[0]), A(r[0])),
                    s = Math.max(parseInt(n[1]), parseInt(r[1])),
                    o = Math.min(parseInt(n[1]), parseInt(r[1]));
                  for (let e = a; e <= i; e++) for (let l = o; l <= s; l++) t.push(`${F(e)}${l}`);
                  return t;
                })(l),
              )).splice(e.indexOf(t), 1);
          }
        });
        return e.filter((e, t, l) => l.indexOf(e) === t);
      })((e = e.toUpperCase()).split(' ').filter((e) => e && e.trim())),
      l = [];
    for (let e = 0; e < t.length; e++) {
      let n = j(t[e]);
      n && l.push(n);
    }
    return l;
  }
  function j(e) {
    let t = e.match(/[A-Z]+|[0-9]+/g),
      l = t.length,
      n = new RegExp('^[A-Z]+$'),
      r = '';
    for (let e = l - 1; e >= 0; e--) {
      let l = t[e];
      n.test(l) ? (r += A(l) + '_') : (r += parseInt(l) - 1 + '_');
    }
    return r.substring(0, r.length - 1);
  }
  function Y(e) {
    if (!e && e?.length <= 0) return '';
    const t = e.length,
      l = e.lastIndexOf('!'),
      n = [e.slice(0, l), e.slice(l + 1, t)],
      r = n[1] || '',
      i = r.indexOf('R'),
      a = r.indexOf('C'),
      s = Number(r.slice(i + 1, a)),
      o = F(Number(r.slice(a + 1, r?.length)) - 1);
    return `${n[0]}!${o}${s}`;
  }
  function $(e) {
    if (!e || e?.length <= 0) return {};
    const t = new RegExp('</x14:formula[^]>', 'g'),
      l = e.match(t)?.length,
      n = `</x14:formula${l}>`,
      r = e.indexOf(n);
    let i = e.substring(0, r + n.length);
    i = i
      .replace(/<xm:f>/g, '')
      .replace(/<\/xm:f>/g, '')
      .replace(/x14:/g, '')
      .replace(/\/x14:/g, '');
    const a = i,
      s = e.indexOf('<xm:sqref>'),
      o = e.indexOf('</xm:sqref>');
    return { formula: a, sqref: e.substring(s + 10, o) };
  }
  function Z(e) {
    if (!e || e?.length <= 0) return [];
    const t = new RegExp('formula', 'g'),
      l = (e.match(t)?.length || 0) / 2;
    if (0 === l) return [];
    let n = [];
    for (let t = 1; t <= l; t++) {
      const l = `<formula${t}>`?.length,
        r = e.indexOf(`<formula${t}>`),
        i = e.indexOf(`</formula${t}>`),
        a = e.substring(r + l, i);
      n.push(W(a.replace(/&quot;|^\"|\"$/g, '')));
    }
    return n;
  }
  function J(e) {
    let t = e.replace(/[^0-9]/g, ''),
      l = e.replace(/[^A-Za-z]/g, ''),
      n = e.substr(e.indexOf(t) - 1, 1),
      r = e.substr(e.indexOf(l) - 1, 1),
      i = [!1, !1];
    return '$' == n && (i[0] = !0), '$' == r && (i[1] = !0), i;
  }
  function K(e) {
    if (null == e || 0 === e.length) return Number.NaN;
    const t = e.toLowerCase().split(''),
      l = t.length;
    let n = 0,
      r = 0;
    for (let e = 0; e < l; e++) (r = t[e].charCodeAt(0) - 96), (n += r * 26 ** (l - e - 1));
    return 0 === n ? Number.NaN : n - 1;
  }
  (H.operator = '==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^'),
    (H.error = {
      v: '#VALUE!',
      n: '#NAME?',
      na: '#N/A',
      r: '#REF!',
      d: '#DIV/0!',
      nm: '#NUM!',
      nl: '#NULL!',
      sp: '#SPILL!',
    }),
    (H.operatorjson = null);
  const Q = 'A'.charCodeAt(0),
    ee = 'Z'.charCodeAt(0);
  function te(e) {
    const t = ee - Q + 1;
    let l = '';
    for (; e >= 0; ) (l = String.fromCharCode((e % t) + Q) + l), (e = Math.floor(e / t) - 1);
    return l;
  }
  function le(e) {
    if (null == e) return e;
    try {
      return Number.isNaN(Number(e)) ? e : Number(e);
    } catch (t) {
      return e;
    }
  }
  function ne(t = 21, l) {
    return l ? e.customAlphabet(l, t)() : e.nanoid(t);
  }
  function re(e) {
    if (!e) return {};
    try {
      return JSON.parse(e);
    } catch (e) {
      return null;
    }
  }
  function ie(e) {
    return '[object Object]' === Object.prototype.toString.call(e);
  }
  function ae(e) {
    for (const t in e)
      Object.prototype.hasOwnProperty.call(e, t) &&
        (void 0 === e[t] ? delete e[t] : ie(e[t]) && null !== e[t] && ae(e[t]));
    return e;
  }
  function se(e) {
    return null == e;
  }
  class oe {
    getElementsByOneTag(e, t) {
      let l;
      if (e.indexOf('|') > -1) {
        let t = e.split('|'),
          n = '';
        for (let e = 0; e < t.length; e++) {
          let l = t[e];
          n +=
            '|<' +
            l +
            ' [^>]+?[^/]>[\\s\\S]*?</' +
            l +
            '>|<' +
            l +
            ' [^>]+?/>|<' +
            l +
            '>[\\s\\S]*?</' +
            l +
            '>|<' +
            l +
            '/>';
        }
        (n = n.substr(1, n.length)), (l = new RegExp(n, 'g'));
      } else l = new RegExp('<' + e + ' [^>]+?[^/]>[\\s\\S]*?</' + e + '>|<' + e + ' [^>]+?/>|<' + e + '>[\\s\\S]*?</' + e + '>|<' + e + '/>', 'g');
      let n = t.match(l);
      return null == n ? [] : n;
    }
    getElementByTagLink(e, t) {
      const l = new DOMParser().parseFromString(t, 'text/xml');
      let n = Array.from(l.children);
      if (e.indexOf('/') > -1) {
        let t = e.split('/');
        for (let e = 0; e < t.length; e++) {
          const l = t[e],
            r = n.findIndex((e) => Array.from(e.children).findIndex((e) => e.tagName === l) > -1);
          if (-1 === r && e <= t.length - 1) return [];
          n = Array.from(n[r].children).filter((e) => e.tagName === l);
        }
      } else n = Array.from(n[0].children).filter((t) => t.tagName === e);
      const r = new XMLSerializer();
      return n.map((e) => r.serializeToString(e));
    }
  }
  class ce extends oe {
    constructor(e) {
      super(), (this.originFile = e);
    }
    getElementsByTagName(e, t, l = !0) {
      let n = this.getFileByName(t);
      l || (n = t);
      let r,
        i = e.split('/');
      for (let e in i) {
        let t = i[e];
        if (null == r) r = this.getElementsByOneTag(t, n);
        else if (r instanceof Array) {
          let e = [];
          for (let l in r) {
            let n = r[l];
            e = e.concat(this.getElementsByOneTag(t, n));
          }
          r = e;
        } else r = this.getElementsByOneTag(t, r);
      }
      let a = [];
      for (let e = 0; e < r.length; e++) {
        let t = new ue(r[e]);
        a.push(t);
      }
      return a;
    }
    getElementsByTagNameLink(e, t, l = !0) {
      let n = this.getFileByName(t);
      l || (n = t);
      const r = this.getElementByTagLink(e, n);
      let i = [];
      for (let e = 0; e < r.length; e++) {
        let t = new ue(r[e]);
        i.push(t);
      }
      return i;
    }
    getFileByName(e) {
      for (let t in this.originFile) if (t.indexOf(e) > -1) return this.originFile[t];
      return '';
    }
  }
  class ue extends oe {
    constructor(e) {
      super(), (this.elementString = e), this.setValue();
      const t = new RegExp('[a-zA-Z0-9_:]*?=".*?"', 'g');
      let l = this.container.match(t);
      if (((this.attributeList = {}), null != l))
        for (let e in l) {
          let t = l[e];
          if (0 == t.length) continue;
          let n = t.substr(0, t.indexOf('=')),
            r = t.substr(t.indexOf('=') + 1);
          null != n &&
            null != r &&
            0 != n.length &&
            0 != r.length &&
            (this.attributeList[n] = r.substr(1, r.length - 2));
        }
    }
    get(e) {
      return this.attributeList[e];
    }
    getInnerElements(e) {
      let t = this.getElementsByOneTag(e, this.elementString),
        l = [];
      for (let e = 0; e < t.length; e++) {
        let n = new ue(t[e]);
        l.push(n);
      }
      return 0 == l.length ? null : l;
    }
    getInnerElementsTagLink(e) {
      const t = this.getElementByTagLink(e, this.elementString);
      let l = [];
      for (let e = 0; e < t.length; e++) {
        let n = new ue(t[e]);
        l.push(n);
      }
      return 0 == l.length ? null : l;
    }
    setValue() {
      let e = this.elementString;
      if ('/>' == e.substr(e.length - 2, 2)) (this.value = ''), (this.container = e);
      else {
        let t = this.getFirstTag();
        let l = new RegExp(
          '(<' + t + ' [^>]+?[^/]>)([\\s\\S]*?)</' + t + '>|(<' + t + '>)([\\s\\S]*?)</' + t + '>',
          'g',
        ).exec(e);
        null != l &&
          (null != l[1]
            ? ((this.container = l[1]), (this.value = l[2]))
            : ((this.container = l[3]), (this.value = l[4])));
      }
    }
    getFirstTag() {
      let e = this.elementString,
        t = e.substr(0, e.indexOf(' '));
      return (
        ('' == t || t.indexOf('>') > -1) && (t = e.substr(0, e.indexOf('>'))),
        (t = t.substr(1, t.length)),
        t
      );
    }
  }
  function he(e, t, l = 'g') {
    let n = e.attributeList,
      r = t.clrScheme,
      i = t.indexedColors;
    t.mruColors;
    let a,
      s = (function (e, t) {
        let l = {};
        if (null == e || 0 == e.length) return t;
        for (let n in t) {
          let r = t[n],
            i = e[parseInt(n)];
          if (null == i) l[n] = r;
          else {
            let e = i.attributeList.rgb;
            l[n] = e;
          }
        }
        return l;
      })(i, v),
      o = n.indexed,
      c = n.rgb,
      u = n.theme,
      h = n.tint;
    if (null != o) {
      (a = s[parseInt(o)]), null != a && ((a = a.substring(a.length - 6, a.length)), (a = '#' + a));
    } else if (null != c) (c = c.substring(c.length - 6, c.length)), (a = '#' + c);
    else if (null != u) {
      let e = parseInt(u);
      0 == e ? (e = 1) : 1 == e ? (e = 0) : 2 == e ? (e = 3) : 3 == e && (e = 2);
      let t = r[e];
      if (null != t) {
        let e = t.getInnerElements('a:sysClr|a:srgbClr');
        if (null != e) {
          let t = e[0],
            l = t.attributeList;
          t.container.indexOf('sysClr') > -1
            ? null != l.lastClr
              ? (a = '#' + l.lastClr)
              : null != l.val && (a = '#' + l.val)
            : t.container.indexOf('srgbClr') > -1 && (a = '#' + l.val);
        }
      }
    }
    if (null != h) {
      let e = parseFloat(h);
      null != a && (a = X(a, e));
    }
    return a;
  }
  function fe(e, t) {
    let l,
      n = e.getInnerElements(t);
    if (null != n && n.length > 0)
      if ('b' == t || 'i' == t || 'strike' == t) l = '1';
      else if ('u' == t) {
        let e = n[0].attributeList.val;
        l =
          'double' == e ? '2' : 'singleAccounting' == e ? '3' : 'doubleAccounting' == e ? '4' : '1';
      } else if ('vertAlign' == t) {
        let e = n[0].attributeList.val;
        'subscript' == e ? (l = '1') : 'superscript' == e && (l = '2');
      } else l = n[0].attributeList.val;
    return l;
  }
  class ge {}
  class de {}
  class me {}
  class pe {}
  class Ee {}
  class be {}
  class Te {}
  class ye {}
  class ve {}
  class we {}
  class Ie {}
  class Ce {}
  class Re {}
  class Le {}
  class Se {}
  class xe {}
  class Ne {}
  var Oe;
  function Me(e, t) {
    if (null == e) return null;
    let l = e[0],
      n = l.attributeList.style;
    if (null == n || 'none' == n) return null;
    let r = l.getInnerElements('color'),
      i = '#000000';
    if (null != r) {
      (i = he(r[0], t, 'b')), null == i && (i = '#000000');
    }
    let a = new Ce();
    return (a.style = w[n]), (a.color = i), a;
  }
  function Ae(e, t) {
    const l = new Ie();
    let n = !1;
    if (!e) return { borderCellValue: l, isAdd: n };
    let r = e.getInnerElements('left'),
      i = e.getInnerElements('right'),
      a = e.getInnerElements('top'),
      s = e.getInnerElements('bottom'),
      o = e.getInnerElements('diagonal'),
      c = e.getInnerElements('start'),
      u = e.getInnerElements('end'),
      h = Me(r, t),
      f = Me(i, t),
      g = Me(a, t),
      d = Me(s, t),
      m = Me(o, t),
      p = Me(c, t),
      E = Me(u, t);
    if (
      (null != p && null != p.color && ((l.l = p), (n = !0)),
      null != E && null != E.color && ((l.r = E), (n = !0)),
      null != h && null != h.color && ((l.l = h), (n = !0)),
      null != f && null != f.color && ((l.r = f), (n = !0)),
      null != g && null != g.color && ((l.t = g), (n = !0)),
      null != d && null != d.color && ((l.b = d), (n = !0)),
      null != m && null != m.color)
    ) {
      const t = e.attributeList.diagonalUp,
        r = e.attributeList.diagonalDown;
      '1' === t && (l.bl_tr = m), '1' === r && (l.tl_br = m), (n = !0);
    }
    return { borderCellValue: l, isAdd: n };
  }
  function Fe(e, t) {
    let l = e.getInnerElements('patternFill');
    if (null != l) {
      let e,
        n,
        r = l[0],
        i = r.getInnerElements('fgColor'),
        a = r.getInnerElements('bgColor');
      if (null != i) {
        e = he(i[0], t);
      }
      if (null != a) {
        n = he(a[0], t);
      }
      if (null != e) return e;
      if (null != n) return n;
    } else {
      if (null != e.getInnerElements('gradientFill')) return null;
    }
  }
  function Be(e, t) {
    let l = null;
    const n = new be();
    let r = e.getInnerElements('sz'),
      i = e.getInnerElements('color'),
      a = e.getInnerElements('name'),
      s = e.getInnerElements('family');
    e.getInnerElements('charset');
    let o = e.getInnerElements('b'),
      c = e.getInnerElements('i'),
      u = e.getInnerElements('strike'),
      h = e.getInnerElements('u');
    if (null != r && r.length > 0) {
      let e = r[0].attributeList.val;
      null != e && (n.fs = parseInt(e));
    }
    if (null != i && i.length > 0) {
      let e = he(i[0], t, 't');
      null != e && (n.fc = e);
    }
    if (null != s && s.length > 0) {
      let e = s[0].attributeList.val;
      null != e && (l = C[e]);
    }
    if (null != a && a.length > 0) {
      let e = a[0].attributeList.val;
      null != e && (n.ff = e);
    }
    if (null != o && o.length > 0) {
      let e = o[0].attributeList.val;
      n.bl = '0' == e ? 0 : 1;
    }
    if (null != c && c.length > 0) {
      let e = c[0].attributeList.val;
      n.it = '0' == e ? 0 : 1;
    }
    if (null != u && u.length > 0) {
      let e = u[0].attributeList.val;
      n.cl = '0' == e ? 0 : 1;
    }
    if (null != h && h.length > 0) {
      let e = h[0].attributeList.val;
      n.un =
        'single' == e
          ? 1
          : 'double' == e
          ? 2
          : 'singleAccounting' == e
          ? 3
          : 'doubleAccounting' == e
          ? 4
          : 0;
    }
    return { cellValue: n, familyFont: l };
  }
  !(function (e) {
    (e[(e.NONE = 0)] = 'NONE'),
      (e[(e.ROW = 1)] = 'ROW'),
      (e[(e.COLUMN = 2)] = 'COLUMN'),
      (e[(e.ALL = 3)] = 'ALL');
  })(Oe || (Oe = {}));
  const Pe = (e) =>
    e.split(' ').map((e) => {
      const t = e.split(':'),
        l = parseInt(t[0].replace(/[^0-9]/g, '')) - 1,
        n = K(t[0].replace(/[^A-Za-z]/g, '')),
        r = J(t[0]),
        i = 1 === t.length ? l : parseInt(t[1].replace(/[^0-9]/g, '')) - 1,
        a = 1 === t.length ? n : K(t[1].replace(/[^A-Za-z]/g, '')),
        s = 1 === t.length ? r : J(t[1]),
        o = (e) =>
          !0 === e[0] && !0 === e[1]
            ? Oe.ALL
            : !0 === e[0]
            ? Oe.ROW
            : !0 === e[1]
            ? Oe.COLUMN
            : Oe.NONE;
      return {
        startRow: l,
        startColumn: n,
        endRow: i,
        endColumn: a,
        startAbsoluteRefType: o(r),
        endAbsoluteRefType: o(s),
        rangeType: 0,
      };
    });
  class ke extends Ee {
    constructor(e, t, l, n, r, i, a, s, o) {
      super(),
        (this.cell = e),
        (this.sheetFile = i),
        (this.styles = l),
        (this.sharedStrings = n),
        (this.readXml = o),
        (this.mergeCells = r),
        (this.cellImages = a),
        (this.imageList = s),
        (this.cellSize = t);
      let c = e.attributeList,
        u = c.r,
        h = c.s,
        f = c.t,
        g = M(u);
      (this.r = g.row[0]), (this.c = g.column[0]), (this.v = this.generateValue(h, f));
    }
    generateValue(e, t) {
      let l = this.cell.getInnerElements('v'),
        n = this.cell.getInnerElements('f');
      null == l && (l = this.cell.getInnerElements('t'));
      let r = this.styles.cellXfs,
        i = this.styles.cellStyleXfs;
      this.styles.cellStyles;
      let a = this.styles.fonts,
        s = this.styles.fills,
        o = this.styles.borders,
        c = this.styles.numfmts;
      this.styles.clrScheme;
      let u = this.sharedStrings,
        h = new be();
      if (null != n) {
        let e = n[0].attributeList,
          t = e.t,
          l = e.ref,
          r = e.si,
          i = n[0].value;
        'shared' == t && ((this._fomulaRef = l), (this._formulaType = t), (this._formulaSi = r)),
          (null != l || (null != i && i.length > 0)) &&
            ((i = W(i)), (h.f = '=' === i[0] ? i : '=' + i));
      }
      let f,
        g = null;
      if (null != e) {
        let l,
          n,
          u,
          d,
          m,
          p,
          E,
          b,
          T,
          y = r[parseInt(e)],
          v = y.attributeList.xfId;
        if (null != v) {
          let e = i[parseInt(v)],
            t = e.attributeList,
            r = t.applyNumberFormat,
            a = t.applyFont,
            s = t.applyFill,
            o = t.applyBorder,
            c = t.applyAlignment;
          if (
            (t.applyProtection,
            (f = t.quotePrefix),
            '0' != r && null != t.numFmtId && (l = t.numFmtId),
            '0' != a && null != t.fontId && (n = t.fontId),
            '0' != s && null != t.fillId && (u = t.fillId),
            '0' != o && null != t.borderId && (d = t.borderId),
            null != c && '0' != c)
          ) {
            let t = e.getInnerElements('alignment');
            if (null != t) {
              let e = t[0].attributeList;
              null != e.horizontal && (m = e.horizontal),
                null != e.vertical && (p = e.vertical),
                null != e.wrapText && (E = e.wrapText),
                null != e.textRotation && (b = e.textRotation),
                null != e.shrinkToFit && e.shrinkToFit,
                null != e.indent && (T = e.indent);
            }
          }
        }
        let w = y.attributeList.applyNumberFormat,
          I = y.attributeList.applyFont,
          C = y.attributeList.applyFill,
          R = y.attributeList.applyBorder,
          L = y.attributeList.applyAlignment;
        if (
          (null != y.attributeList.applyProtection && y.attributeList.applyProtection,
          null != y.attributeList.quotePrefix && (f = y.attributeList.quotePrefix),
          '0' != w && null != y.attributeList.numFmtId && (l = y.attributeList.numFmtId),
          '0' != I && (n = y.attributeList.fontId),
          '0' != C && (u = y.attributeList.fillId),
          '0' != R && (d = y.attributeList.borderId),
          '0' != L)
        ) {
          let e = y.getInnerElements('alignment');
          if (null != e && e.length > 0) {
            let t = e[0].attributeList;
            null != t.horizontal && (m = t.horizontal),
              null != t.vertical && (p = t.vertical),
              null != t.wrapText && (E = t.wrapText),
              null != t.textRotation && (b = t.textRotation),
              null != t.shrinkToFit && t.shrinkToFit,
              null != t.indent && (T = t.indent);
          }
        }
        if (null != l) {
          let e = c[parseInt(l)],
            n = new Te();
          (n.fa = W(e)), (n.t = t || 'd'), (h.ct = n);
        }
        if (null != u) {
          let e = Fe(s[parseInt(u)], this.styles);
          null != e && (h.bg = e);
        }
        if (null != n) {
          let e = a[parseInt(n)];
          if (null != e) {
            const { cellValue: t, familyFont: l } = Be(e, this.styles);
            (h = { ...h, ...t }), (g = l);
          }
        }
        if (
          (null != m &&
            (h.ht =
              'center' == m || 'centerContinuous' == m
                ? 0
                : 'left' == m
                ? 1
                : 'right' == m
                ? 2
                : 'distributed' == m
                ? 0
                : 'fill' == m || 'general' == m
                ? 1
                : 'justify' == m
                ? 0
                : 1),
          (h.vt =
            null != p
              ? 'bottom' == p
                ? 2
                : 'center' == p || 'distributed' == p || 'justify' == p
                ? 0
                : 1
              : 2),
          (h.tb = null != E && '1' == E ? 2 : 1),
          null != b && ('255' == b ? (h.tr = 3) : ((h.tr = 0), (h.rt = parseInt(b)))),
          null != T)
        ) {
          const e = parseInt(T);
          isNaN(e) || (h.ti = e);
        }
        if (null != d) {
          let e = o[parseInt(d)],
            t = new we();
          t.rangeType = 'cell';
          const { isAdd: l, borderCellValue: n } = Ae(e, this.styles);
          (n.row_index = this.r),
            (n.col_index = this.c),
            l && ((t.value = n), (this._borderObject = t));
        }
      } else h.tb = 1;
      if (null != l) {
        let e = l[0].value;
        if ((/&#\d+;/.test(e) && (e = this.htmlDecode(e)), t == b)) {
          let e = u[parseInt(l[0].value)],
            t = e.getInnerElements('r');
          if (null == t) {
            let t = e.getInnerElements('t');
            if (null != t) {
              let e = '';
              if (
                (t.forEach((t) => {
                  e += t.value;
                }),
                (e = W(e)),
                'Roman' == g && e.length > 0)
              ) {
                let t = e.split(''),
                  l = null,
                  n = '',
                  r = null,
                  i = 'Times New Roman';
                null != h.ff && (i = h.ff);
                let a = h.ct;
                null == a && (a = new Te()), null == a.s && (a.s = []);
                for (let e = 0; e < t.length; e++) {
                  let s = t[e],
                    o = null,
                    c = i;
                  if (
                    (/[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/.test(
                      (m = s),
                    ) || !/[^\u4e00-\u9fa5]/.test(m)
                      ? ((o = 'c'), (c = '宋体'))
                      : z(s)
                      ? ((o = 'j'), (c = 'Yu Gothic'))
                      : ((d = s) > 12592 && d < 12687) || (d >= 44032 && d <= 55203)
                      ? ((o = 'k'), (c = 'Malgun Gothic'))
                      : (o = 'e'),
                    (o != l && null != l) || e == t.length - 1)
                  ) {
                    let i = new ye();
                    if (
                      ((i.ff = r),
                      null != h.fc && (i.fc = h.fc),
                      null != h.fs && (i.fs = h.fs),
                      null != h.cl && (i.cl = h.cl),
                      null != h.un && (i.un = h.un),
                      null != h.bl && (i.bl = h.bl),
                      null != h.it && (i.it = h.it),
                      e == t.length - 1)
                    ) {
                      if (o != l) {
                        (i.ff = r), (i.v = n), a.s.push(i);
                        let e = new ye();
                        (e.ff = c),
                          (e.v = s),
                          null != h.fc && (e.fc = h.fc),
                          null != h.fs && (e.fs = h.fs),
                          null != h.cl && (e.cl = h.cl),
                          null != h.un && (e.un = h.un),
                          null != h.bl && (e.bl = h.bl),
                          null != h.it && (e.it = h.it),
                          a.s.push(e);
                        break;
                      }
                      (i.ff = c), (i.v = n + s);
                    } else i.v = n;
                    a.s.push(i), (n = s);
                  } else n += s;
                  (l = o), (r = c);
                }
                (a.t = 'inlineStr'), (h.ct = a);
              } else if (
                ((e = this.replaceSpecialWrap(e)), e.indexOf('\r\n') > -1 || e.indexOf('\n') > -1)
              ) {
                let t = new ye();
                t.v = e;
                let l = h.ct;
                null == l && (l = new Te()),
                  null != h.ff && (t.ff = h.ff),
                  null != h.fc && (t.fc = h.fc),
                  null != h.fs && (t.fs = h.fs),
                  null != h.cl && (t.cl = h.cl),
                  null != h.un && (t.un = h.un),
                  null != h.bl && (t.bl = h.bl),
                  null != h.it && (t.it = h.it),
                  (l.t = 'inlineStr'),
                  (l.s = [t]),
                  (h.ct = l);
              } else (h.v = e), (f = '1');
            }
          } else {
            let e = [];
            t.forEach((t) => {
              let l = t.getInnerElements('t'),
                n = t.getInnerElements('rPr'),
                r = new ye();
              if (null != l && l.length > 0) {
                let e = l[0].value;
                (e = this.replaceSpecialWrap(e)), (e = W(e)), (r.v = e);
              }
              if (null != n && n.length > 0) {
                let e = n[0],
                  t = fe(e, 'sz'),
                  l = fe(e, 'rFont');
                fe(e, 'family'), fe(e, 'charset'), fe(e, 'scheme');
                let i,
                  a,
                  s = fe(e, 'b'),
                  o = fe(e, 'i'),
                  c = fe(e, 'u'),
                  u = fe(e, 'strike'),
                  f = fe(e, 'vertAlign'),
                  g = e.getInnerElements('color');
                null != g && g.length > 0 && (i = he(g[0], this.styles, 't')),
                  null != l && (a = l),
                  null != a ? (r.ff = a) : null != h.ff && (r.ff = h.ff),
                  null != i && (r.fc = i),
                  null != t ? (r.fs = parseInt(t)) : null != h.fs && (r.fs = h.fs),
                  null != u ? (r.cl = parseInt(u)) : null != h.cl && (r.cl = h.cl),
                  null != c ? (r.un = parseInt(c)) : null != h.un && (r.un = h.un),
                  null != s ? (r.bl = parseInt(s)) : null != h.bl && (r.bl = h.bl),
                  null != o ? (r.it = parseInt(o)) : null != h.it && (r.it = h.it),
                  null != f && (r.va = parseInt(f));
              } else
                null == r.ff && null != h.ff && (r.ff = h.ff),
                  null == r.fc && null != h.fc && (r.fc = h.fc),
                  null == r.fs && null != h.fs && (r.fs = h.fs),
                  null == r.cl && null != h.cl && (r.cl = h.cl),
                  null == r.un && null != h.un && (r.un = h.un),
                  null == r.bl && null != h.bl && (r.bl = h.bl),
                  null == r.it && null != h.it && (r.it = h.it);
              e.push(r);
            });
            let l = h.ct;
            null == l && (l = new Te()), (l.t = 'inlineStr'), (l.s = e), (h.ct = l);
          }
        } else if (t == E && null != l) h.v = "'" + e;
        else if (t == T && e.includes('=DISPIMG')) {
          let t = h.ct;
          null == t && (t = new Te()), (t.t = 'str'), (t.ci = this.getCellImage(h, e)), (h.ct = t);
        } else (e = W(e)), (h.v = e);
      }
      var d, m;
      if ((null != f && (h.qp = parseInt(f)), null !== t && !h.ct?.t)) {
        let e = new Te();
        (e.t = t || 'd'), (h.ct = e);
      }
      return h;
    }
    replaceSpecialWrap(e) {
      return (e = e
        .replace(/_x000D_/g, '')
        .replace(/&#13;&#10;/g, '\r\n')
        .replace(/&#13;/g, '\r')
        .replace(/&#10;/g, '\n'));
    }
    htmlDecode(e) {
      return e.replace(/&#(x)?([^&]{1,5});/g, function (e, t, l) {
        return String.fromCharCode(parseInt(l, t ? 16 : 10));
      });
    }
    getCellImage(e, t) {
      const l = this.extractImageId(t);
      let n = {};
      return (
        this.cellImages.forEach((e) => {
          const t = e.getInnerElements('xdr:pic')[0],
            r = t.getInnerElements('xdr:nvPicPr')[0].getInnerElements('xdr:cNvPr')[0],
            i = t.getInnerElements('xdr:blipFill')[0].getInnerElements('a:blip')[0],
            a = r.get('name'),
            s = i.get('r:embed');
          if (l == a) {
            const e = this.getBase64ByRid(s, 'xl/_rels/cellimages.xml.rels');
            n = e;
            let l = 0,
              i = 0,
              a = 0,
              o = 0;
            const c = t.getInnerElements('xdr:spPr')[0].getInnerElements('a:xfrm')[0],
              u = c.getInnerElements('a:off')[0],
              h = c.getInnerElements('a:ext')[0];
            (a = B(parseInt(h.get('cx')))),
              (o = B(parseInt(h.get('cy')))),
              (l = B(parseInt(u.get('x')))),
              (i = B(parseInt(u.get('y'))));
            const f = a / this.cellSize.width,
              g = o / this.cellSize.height;
            f > 1 && f > g && ((o /= f), (a = this.cellSize.width)),
              g > 1 && g > f && ((a /= g), (o = this.cellSize.height));
            let d = { height: o, left: l, top: i, width: a };
            (n.default = d), (n.descr = r.get('descr'));
          }
        }),
        n
      );
    }
    extractImageId(e) {
      const t = e.match(/ID_[A-Za-z0-9]{32}/);
      return t ? t[0] : null;
    }
    getBase64ByRid(e, t) {
      let l = this.readXml.getElementsByTagName('Relationships/Relationship', t);
      if (null != l && l.length > 0)
        for (let t = 0; t < l.length; t++) {
          let n = l[t].attributeList,
            r = k(n, 'Id', null),
            i = k(n, 'Target', null);
          if (r == e) {
            return (
              (i = i.replace(/\.\.\//g, '')), (i = 'xl/' + i), this.imageList.getImageByName(i)
            );
          }
        }
      return {};
    }
  }
  var _e, De, Xe, Ge, Ve;
  !(function (e) {
    (e.beginsWith = 'beginsWith'),
      (e.endsWith = 'endsWith'),
      (e.containsText = 'containsText'),
      (e.notContainsText = 'notContainsText'),
      (e.equal = 'equal'),
      (e.notEqual = 'notEqual'),
      (e.containsBlanks = 'containsBlanks'),
      (e.notContainsBlanks = 'notContainsBlanks'),
      (e.containsErrors = 'containsErrors'),
      (e.notContainsErrors = 'notContainsErrors');
  })(_e || (_e = {})),
    (function (e) {
      (e.today = 'today'),
        (e.yesterday = 'yesterday'),
        (e.tomorrow = 'tomorrow'),
        (e.last7Days = 'last7Days'),
        (e.thisMonth = 'thisMonth'),
        (e.lastMonth = 'lastMonth'),
        (e.nextMonth = 'nextMonth'),
        (e.thisWeek = 'thisWeek'),
        (e.lastWeek = 'lastWeek'),
        (e.nextWeek = 'nextWeek');
    })(De || (De = {})),
    (function (e) {
      (e.greaterThan = 'greaterThan'),
        (e.greaterThanOrEqual = 'greaterThanOrEqual'),
        (e.lessThan = 'lessThan'),
        (e.lessThanOrEqual = 'lessThanOrEqual'),
        (e.notBetween = 'notBetween'),
        (e.between = 'between'),
        (e.equal = 'equal'),
        (e.notEqual = 'notEqual');
    })(Xe || (Xe = {})),
    (function (e) {
      (e.highlightCell = 'highlightCell'),
        (e.dataBar = 'dataBar'),
        (e.colorScale = 'colorScale'),
        (e.iconSet = 'iconSet');
    })(Ge || (Ge = {})),
    (function (e) {
      (e.uniqueValues = 'uniqueValues'),
        (e.duplicateValues = 'duplicateValues'),
        (e.rank = 'rank'),
        (e.text = 'text'),
        (e.timePeriod = 'timePeriod'),
        (e.number = 'number'),
        (e.average = 'average'),
        (e.formula = 'formula');
    })(Ve || (Ve = {}));
  class We {
    constructor(e, t, l) {
      (this.stopIfTrue = !1),
        (this.handleRules = (e, t, l) => {
          const { attributeList: n, value: r, extLst: i, isExtLst: a } = e,
            s = k(n, 'type', 'expression'),
            o = { type: Ge.highlightCell },
            c = k(n, 'operator', ''),
            u = k(n, 'rank', ''),
            h = t.getElementsByTagName('formula', r, !1);
          switch (
            (k(n, 'aboveAverage', ''),
            c && (o.operator = c),
            (h[0]?.value || '0' == h[0]?.value) && (o.value = le(h[0]?.value)),
            s)
          ) {
            case 'expression':
              o.subType = Ve.formula;
              break;
            case 'cellIs':
              o.subType = Ve.number;
              break;
            case 'top10':
              o.subType = Ve.rank;
              const e = k(n, 'percent', '0'),
                s = k(n, 'bottom', '0');
              u && (o.value = le(u)), (o.isBottom = '1' === s), (o.isPercent = '1' === e);
              break;
            case 'aboveAverage':
              (o.subType = Ve.average), (o.operator = o.operator || Xe.lessThan);
              break;
            case 'timePeriod':
              (o.subType = Ve.timePeriod), (o.operator = k(n, 'timePeriod', void 0));
              break;
            case 'duplicateValues':
              o.subType = Ve.duplicateValues;
              break;
            case 'containsText':
              (o.subType = Ve.text), (o.operator = 'containsText'), (o.value = k(n, 'text', ''));
              break;
            case 'colorScale':
              const c = t.getElementsByTagName('colorScale/cfvo', r, !1),
                h = t.getElementsByTagName('colorScale/color', r, !1);
              (o.type = Ge.colorScale),
                (o.config = c.map((e, t) => {
                  const n = k(e.attributeList, 'type', ''),
                    r = k(e.attributeList, 'val', void 0);
                  return {
                    index: 0,
                    color: h[t] ? he(h[t], l) : void 0,
                    value: { type: n, value: le(r) },
                  };
                }));
              break;
            case 'dataBar':
              o.type = Ge.dataBar;
              const f = t.getElementsByTagName('dataBar', r, !1)?.[0],
                g = t.getElementsByTagName('cfvo', f.value, !1),
                d = t.getElementsByTagName('color', f.value, !1),
                m = k(f.attributeList, 'showValue', '1');
              o.isShowValue = '1' === m;
              let p = d[0] ? he(d[0], l) : void 0,
                E = !0,
                b = '';
              if (i) {
                const e = k(
                    t.getElementsByTagName('x14:dataBar', i.value, !1)[0].attributeList,
                    'gradient',
                    null,
                  ),
                  n = t.getElementsByTagName('x14:dataBar/x14:negativeFillColor', i.value, !1)?.[0];
                (b = n ? he(n, l) : void 0), (E = '0' !== e);
              }
              o.config = {
                min: {
                  type: k(g[0]?.attributeList, 'type', 'min'),
                  value: le(k(g[0]?.attributeList, 'val', void 0)),
                },
                max: {
                  type: k(g[1]?.attributeList, 'type', 'max'),
                  value: le(k(g[1]?.attributeList, 'val', void 0)),
                },
                isGradient: E,
                positiveColor: p,
                nativeColor: b,
              };
              break;
            case 'iconSet':
              if (((o.type = Ge.iconSet), a)) {
                const e = t.getElementsByTagName('x14:iconSet', r, !1)[0],
                  l = t.getElementsByTagName('x14:iconSet/x14:cfvo', r, !1),
                  n = t.getElementsByTagName('x14:iconSet/x14:cfIcon', r, !1),
                  i = '1' === k(e?.attributeList, 'custom', '0');
                (o.isShowValue = '0' !== e?.attributeList?.showValue),
                  (o.config = l
                    .map((l, r) => {
                      const a = t.getElementsByTagName('xm:f', l.value, !1)[0];
                      let s = n[r]?.attributeList;
                      const o = i ? s?.iconSet : e?.attributeList.iconSet,
                        c = le(o.charAt(0)) - le(s?.iconId) - 1;
                      return {
                        operator: Xe.greaterThanOrEqual,
                        value: { type: l.attributeList.type, value: le(a?.value) },
                        iconType: o,
                        iconId: c,
                      };
                    })
                    .reverse());
              } else {
                const e = t.getElementsByTagName('iconSet', r, !1),
                  l = t.getElementsByTagName('iconSet/cfvo', r, !1);
                (o.isShowValue = '0' !== e[0]?.attributeList?.showValue),
                  (o.config = l.map((t, l) => ({
                    operator: o.operator || Xe.greaterThanOrEqual,
                    value: { type: t.attributeList.type, value: le(t.attributeList.val) },
                    iconType: e[0].attributeList.iconSet,
                    iconId: l,
                  })));
              }
          }
          const f = k(n, 'dxfId', null);
          if (f) {
            let e = l.dxfs;
            const t = null !== f ? e[Number(f)] : void 0,
              n = t.getInnerElements('font')?.[0],
              r = t.getInnerElements('numFmt')?.[0],
              i = t.getInnerElements('fill')?.[0],
              a = t.getInnerElements('border')?.[0];
            let s = l.numfmts,
              c = {};
            if (a) {
              const { borderCellValue: e } = Ae(a, l);
              c.border = e;
            }
            if (i) {
              const e = Fe(i, l);
              c.bg = e;
            }
            if (r) {
              let e = s[parseInt(r?.attributeList?.numFmtId)],
                t = new Te();
              (t.fa = e ? W(e) : r.attributeList.formatCode), (c.ct = t);
            }
            if (n) {
              const { cellValue: e } = Be(n, c);
              c = { ...c, ...e };
            }
            o.style = c;
          }
          this.rule = o;
        });
      const { attributeList: n, parentAttribute: r } = e;
      r?.sqref && (this.ranges = Pe(r.sqref)),
        (this.order = Number(k(n, 'priority', '1'))),
        (this.cfId = V('condition')),
        (this.stopIfTrue = '1' === k(n, 'stopIfTrue', '0')),
        this.handleRules(e, t, l);
    }
  }
  class He {
    constructor(e, t) {
      let l = e.attributeList,
        n = e.value,
        r = k(l, 'type', void 0);
      if (!r) return;
      this.uid = V('verification');
      let i = [],
        a = '';
      const s = k(l, 'operator', void 0),
        o = '1' === k(l, 'allowBlank', void 0),
        c = '1' === k(l, 'showInputMessage', void 0),
        u = '1' === k(l, 'showErrorMessage', void 0),
        h = k(l, 'prompt', void 0),
        f = k(l, 'promptTitle', void 0),
        g = k(l, 'error', void 0),
        d = k(l, 'errorTitle', void 0),
        m = k(l, 'errorStyle', 'stop');
      if (new RegExp(/<x14:formula1>|<xm:sqref>/g).test(n) && t?.length >= 0) {
        const e = $(n);
        (a = e?.sqref), (i = Z(e?.formula));
      } else (i = Z(n)), (a = k(l, 'sqref', null));
      let p = i?.length >= 1 ? i[0] : void 0,
        E = 2 === i?.length ? i[1] : void 0;
      switch (
        (a && (this.ranges = Pe(a)),
        (this.type = r),
        (this.allowBlank = o),
        (this.operator = s),
        (this.formula1 = p),
        (this.formula2 = E),
        (this.showErrorMessage = u),
        (this.showInputMessage = c),
        (this.prompt = h),
        (this.promptTitle = f),
        (this.error = g),
        (this.errorTitle = d),
        m)
      ) {
        case 'information':
          this.errorStyle = 0;
          break;
        case 'warning':
          this.errorStyle = 2;
          break;
        case 'stop':
          this.errorStyle = 1;
      }
      this.ranges = Pe(a);
    }
  }
  class ze {
    constructor(e, t) {
      const l = e.getElementsByTagName('autoFilter', t)[0];
      if (!l) return;
      this.ref = Pe(l.attributeList.ref)?.[0];
      const n = l.getInnerElements('filterColumn');
      this.filterColumns = n.map((e) => {
        const t = e.getInnerElements('filters')?.[0],
          l = t.getInnerElements('filter');
        return {
          colId: le(e.attributeList.colId),
          filters: {
            blank: '1' === t.attributeList?.blank,
            filters: l.map((e) => e.attributeList.val),
          },
        };
      });
    }
  }
  class qe {
    constructor(e) {
      const t = k(e.attributeList, 'xSplit', '0'),
        l = k(e.attributeList, 'ySplit', '0');
      (this.horizen = Number(l)), (this.vertical = Number(t));
    }
  }
  const Ue = (e, t) => {
    const l = e.getElementsByTagName('c:barChart', t)[0],
      n = e.getElementsByTagName('c:lineChart', t)[0],
      r = e.getElementsByTagName('c:pieChart', t)[0],
      i = e.getElementsByTagName('c:doughnutChart', t)[0],
      a = e.getElementsByTagName('c:areaChart', t)[0],
      s = e.getElementsByTagName('c:radarChart', t)[0],
      o = e.getElementsByTagName('c:scatterChart', t)[0];
    let c = [],
      u = l,
      h = N.Column;
    if (l) {
      const e = l.getInnerElements('c:barDir')?.[0]?.get('val'),
        t = l.getInnerElements('c:grouping')?.[0]?.get('val');
      'col' === e
        ? ((h = N.Column),
          'stacked' === t
            ? (h = N.ColumnStacked)
            : 'percentStacked' === t && (h = N.ColumnPercentStacked))
        : 'bar' === e &&
          ((h = N.Bar),
          'stacked' === t
            ? (h = N.BarStacked)
            : 'percentStacked' === t && (h = N.BarPercentStacked)),
        (u = l),
        c.push({ chartEle: u, chartType: h });
    }
    if (
      (n && ((u = n), (h = N.Line), c.push({ chartEle: u, chartType: h })),
      r && ((u = r), (h = N.Pie), c.push({ chartEle: u, chartType: h })),
      i && ((u = i), (h = N.Doughnut), c.push({ chartEle: u, chartType: h })),
      a)
    ) {
      (u = a), (h = N.Area);
      const e = a.getInnerElements('c:grouping')?.[0]?.get('val');
      'stacked' === e ? (h = N.AreaStacked) : 'percentStacked' === e && (h = N.AreaPercentStacked),
        c.push({ chartEle: u, chartType: h });
    }
    return (
      s && ((u = s), (h = N.Radar), c.push({ chartEle: u, chartType: h })),
      o && ((u = o), (h = N.Scatter), c.push({ chartEle: u, chartType: h })),
      c.length > 1 && ((h = N.Combination), (u = c)),
      { chartEle: u, chartType: h }
    );
  };
  class je extends xe {
    constructor(e, t, l, n) {
      super(),
        (this.id = e),
        (this.type = 'chart'),
        (this.data = {
          chartType: n,
          range: l,
          border: '#979DAC',
          background: 'rgba(0,0,0,0)',
          isRowDirection: !0,
        });
      let r = 0,
        i = 0,
        a = 0,
        s = 0;
      const o = t.getInnerElements('a:off')[0],
        c = t.getInnerElements('a:ext')[0];
      (a = B(parseInt(c.get('cx')))),
        (s = B(parseInt(c.get('cy')))),
        (r = B(parseInt(o.get('x')))),
        (i = B(parseInt(o.get('y')))),
        (this.transform = { width: a, height: s, top: i, left: r });
    }
  }
  class Ye {
    constructor({ graphicFrame: e, readXml: t, drawingRelsFile: n, styles: r }) {
      (this.getChartRange = (e) => {
        let t = 0,
          n = 0,
          r = 0,
          i = 0;
        if (Array.isArray(e)) {
          e.map((e) => this.getChartRef(e.chartEle.value)).forEach((e, l) => {
            0 === l
              ? ((t = e.maxColumn), (n = e.maxRow), (r = e.minColumn), (i = e.minRow))
              : ((t = Math.max(t, e.maxColumn)),
                (n = Math.max(n, e.maxRow)),
                (r = Math.min(r, e.minColumn)),
                (i = Math.min(i, e.minRow)));
          });
        } else {
          const l = this.getChartRef(e.value);
          (t = l.maxColumn), (n = l.maxRow), (r = l.minColumn), (i = l.minRow);
        }
        const a = l.numberToABC(t) + (n + 1);
        return l.numberToABC(r) + (i + 1) + ':' + a;
      }),
        (this.getChartRef = (e) => {
          const t = this.readXml.getElementsByTagName('c:ser/c:cat/c:numRef/c:f', e, !1)?.[0],
            l = this.readXml.getElementsByTagName('c:ser/c:cat/c:strRef/c:f', e, !1)?.[0],
            n = this.readXml.getElementsByTagName('c:ser/c:xVal/c:strRef/c:f', e, !1)?.[0],
            r = this.readXml.getElementsByTagName('c:ser/c:xVal/c:numRef/c:f', e, !1)?.[0],
            i = t || l || n || r,
            a = this.readXml.getElementsByTagName('c:ser/c:tx/c:strRef/c:f', e, !1),
            s = i,
            o = a[a.length - 1],
            c = M(s.value),
            u = M(o.value),
            h = [...c.column, ...u.column],
            f = [...c.row, ...u.row];
          return {
            maxColumn: Math.max(...h),
            maxRow: Math.max(...f),
            minColumn: Math.min(...h),
            minRow: Math.min(...f),
          };
        }),
        (this.readXml = t);
      const i = e.getInnerElements('xdr:xfrm')[0],
        a = (function (e) {
          const { rid: t, fileName: l, callback: n, readXml: r } = e;
          let i = r.getElementsByTagName('Relationships/Relationship', l);
          if (null != i && i.length > 0)
            for (let e = 0; e < i.length; e++) {
              let l = i[e].attributeList,
                r = k(l, 'Id', null),
                a = k(l, 'Target', null);
              if (r == t) return (a = a.replace(/\.\.\//g, '')), n ? n(a) : a;
            }
          return null;
        })({
          rid: t
            .getElementsByTagName('a:graphic/a:graphicData/c:chart', e.value, !1)[0]
            .get('r:id'),
          fileName: n,
          readXml: t,
        }),
        { chartEle: s, chartType: o } = Ue(t, a),
        c = this.getChartRange(s),
        u = ne();
      this.image = new je(u, i, c, o);
      const h = new $e({
        id: u,
        range: c,
        chartType: o,
        chartFile: a,
        readXml: t,
        image: this.image,
        styles: r,
      });
      this.chart = h.model;
    }
  }
  class $e extends Ne {
    constructor(e) {
      super(),
        (this.getStyle = (e) => {
          const t = this.readXml.getElementsByTagNameLink('c:spPr', this.chartFile)[0],
            l = t.getInnerElements('a:solidFill')[0],
            n = t.getInnerElements('a:ln')[0],
            r = l ? this.getColor(l.getInnerElements('a:schemeClr')[0]) : void 0,
            i = n ? this.getColor(n.getInnerElements('a:schemeClr')[0]) : void 0,
            a = this.getAllTitle(),
            s = this.readXml.getElementsByTagNameLink(
              'c:chart/c:autoTitleDeleted',
              this.chartFile,
            )[0],
            o = this.readXml.getElementsByTagNameLink('c:chart/c:plotArea', this.chartFile)[0],
            c = this.getAxis(o?.getInnerElements('c:catAx')?.[0]),
            u = this.getAxis(o?.getInnerElements('c:valAx')?.[0]),
            h = this.readXml.getElementsByTagNameLink('c:chart/c:legend', this.chartFile)[0],
            f = this.getLegend(h);
          return {
            titles: { ...a, titlePosition: '1' === s?.get('val') ? 'hide' : 'top' },
            runtime: {},
            width: e.transform.width,
            height: e.transform.height,
            backgroundColor: r,
            borderColor: i,
            xAxis: c,
            yAxis: u,
            legend: f,
            ...this.getChartSeries(),
          };
        }),
        (this.getChartSeries = () => {
          const { chartEle: e, chartType: t } = Ue(this.readXml, this.chartFile);
          if (!e) return {};
          if (Array.isArray(e)) {
            return {
              seriesStyleMap: e
                .map((e) => this.getChartSeriesBase(e.chartEle, e.chartType, !0))
                .reduce((e, t) => Object.assign(e, t), {}),
            };
          }
          const l = e.getInnerElementsTagLink('c:dLbls')[0].getInnerElements('c:showVal')[0];
          return {
            allSeriesStyle: { label: { visible: !!l && '1' === l.get('val') } },
            seriesStyleMap: this.getChartSeriesBase(e, t),
          };
        }),
        (this.getChartSeriesBase = (e, t, l) => {
          const n = e.getInnerElements('c:ser'),
            r = {};
          return (
            n.forEach((e) => {
              const n = e.getInnerElements('c:idx')[0],
                i = parseInt(n.get('val')) + 1,
                a = e.getInnerElements('c:spPr')[0],
                s = a?.getInnerElementsTagLink('a:solidFill')?.[0],
                o = a?.getInnerElements('a:ln')?.[0],
                c = this.getColor(s?.getInnerElements('a:schemeClr')?.[0]),
                u = s?.getInnerElements('a:alpha')?.[0]?.get('val'),
                h = o ? this.getLine(o) : void 0,
                f = e.getInnerElements('c:dLbls')[0],
                g = f.getInnerElements('c:showVal')?.[0]?.get('val'),
                d = f.getInnerElements('c:showCatName')?.[0]?.get('val'),
                m = f.getInnerElements('c:showSerName')?.[0]?.get('val'),
                p = f.getInnerElements('c:showPercent')?.[0]?.get('val'),
                E = this.getBaseStyle(f.getInnerElements('a:defRPr')?.[0]),
                b =
                  ('1' === g ? O.Value : 0) |
                  ('1' === d ? O.CategoryName : 0) |
                  ('1' === m ? O.SeriesName : 0) |
                  ('1' === p ? O.Percentage : 0),
                T = {
                  border: h,
                  label: { visible: !!b, contentType: b, ...E },
                  color: c,
                  fillOpacity: u ? parseInt(u) / 1e5 : 1,
                  chartType: l ? t : void 0,
                };
              let y = this.getExtraSerise(T, e, t);
              r[i] = y;
            }),
            r
          );
        }),
        (this.getExtraSerise = (e, t, l) => {
          if (l === N.Line) {
            e.border?.color && (e.color = e.border.color);
            const l = t.getInnerElements('c:marker')[0],
              n = l.getInnerElements('c:symbol')?.[0]?.get('val'),
              r = l.getInnerElements('c:size')?.[0]?.get('val'),
              i = l.getInnerElementsTagLink('c:spPr/a:solidFill/a:schemeClr')?.[0],
              a = this.getColor(i);
            e.point = {
              color: a,
              size: r ? parseInt(r) : void 0,
              shape: 'none' === n && e.label.visible ? 'circle' : n,
            };
          }
          return e;
        }),
        (this.getLegend = (e) => {
          if (!e) return { position: 'hide' };
          const t = e.getInnerElements('c:legendPos')[0]?.get('val'),
            l = e.getInnerElements('c:txPr')[0].getInnerElements('a:pPr')[0],
            n = this.getBaseStyle(l.getInnerElements('a:defRPr')[0]);
          return {
            position: t ? { t: 'top', b: 'bottom', l: 'left', r: 'right' }[t] : 'bottom',
            label: n,
          };
        }),
        (this.getAxis = (e) => {
          if (!e) return;
          const t = !e.getInnerElementsTagLink('c:spPr/a:ln/a:noFill')?.length,
            l = e.getInnerElements('c:scaling')[0],
            n = 'maxMin' === l?.getInnerElements('c:orientation')[0]?.get('val'),
            r = l?.getInnerElements('c:max')?.[0]?.get('val'),
            i = l?.getInnerElements('c:min')?.[0]?.get('val'),
            a = e.getInnerElements('c:lblAlgn')?.[0]?.get('val'),
            s = e.getInnerElements('c:txPr')[0],
            o = s.getInnerElements('a:pPr')[0],
            c = s?.getInnerElements('a:bodyPr')?.[0]?.get('rot'),
            u = this.getBaseStyle(o.getInnerElements('a:defRPr')[0]),
            h = e.getInnerElements('c:majorGridlines')?.[0],
            f = h?.getInnerElements('a:ln')[0],
            g = f?.get('w') ? B(parseInt(f.get('w'))) : void 0,
            d = e.getInnerElements('c:majorTickMark')?.[0],
            m = this.getColor(f?.getInnerElements('a:schemeClr')?.[0]);
          return {
            lineVisible: t,
            reverse: n,
            max: r ? parseInt(r) : void 0,
            min: i ? parseInt(i) : void 0,
            label: {
              axisTitleAlign: a ? { l: 'start', r: 'end', ctr: 'center' }[a] : 'center',
              rotate: c && parseInt(c) > 0 ? parseInt(c) / 6e4 : 0,
              ...u,
            },
            gridLine: { visible: !!h?.value, width: g, color: m },
            tick: {
              visible: 'none' !== d?.get('val'),
              position: 'out' === d?.get('val') ? 'outside' : 'inside',
              lineWidth: g,
            },
          };
        }),
        (this.getLine = (e) => {
          const t = e?.get('w') ? B(parseInt(e.get('w'))) : 0,
            l = this.getColor(e?.getInnerElements('a:schemeClr')?.[0]),
            n = e.getInnerElements('a:prstDash')?.[0]?.get('val'),
            r = {
              solid: 'solid',
              dot: 'dotted',
              dash: 'dashed',
              sysDot: 'dotted',
              sysDash: 'dashed',
              lgDash: 'dashed',
            };
          return { dashType: n && r[n] ? r[n] : 'solid', color: l, width: t };
        }),
        (this.getAllTitle = () => {
          const e = this.readXml.getElementsByTagNameLink('c:chart/c:title', this.chartFile)[0],
            t = this.readXml.getElementsByTagNameLink(
              'c:chart/c:plotArea/c:catAx/c:title',
              this.chartFile,
            )[0],
            l = this.readXml.getElementsByTagNameLink(
              'c:chart/c:plotArea/c:valAx/c:title',
              this.chartFile,
            )[0];
          return {
            title: this.getTitle(e),
            xAxisTitle: this.getTitle(t),
            yAxisTitle: this.getTitle(l),
          };
        }),
        (this.getTitle = (e) => {
          if (!e) return;
          const t = e.getInnerElements('a:r'),
            l = e.getInnerElements('a:pPr')[0],
            n = this.getBaseStyle(l.getInnerElements('a:defRPr')[0]),
            r = t?.map((e) => this.getBaseStyle(e.getInnerElements('a:rPr')?.[0])) || [];
          return {
            content: t?.map((e) => e.getInnerElements('a:t')[0].value).join(''),
            ...n,
            ...(r.length ? r[0] : {}),
          };
        }),
        (this.getBaseStyle = (e) => {
          if (!e) return {};
          const t = e.getInnerElements('a:schemeClr')?.[0],
            l = e.getInnerElements('a:solidFill')?.[0],
            n = !t && l ? this.getThemColor(l) : this.getColor(t),
            r = {};
          return (
            e.get('sz') && (r.fontSize = parseInt(e.get('sz')) / 100),
            e.get('b') && (r.bold = '1' === e.get('b')),
            e.get('i') && (r.italic = '1' === e.get('i')),
            n && (r.color = n),
            r
          );
        }),
        (this.getColor = (e) => {
          if (!e) return;
          const t = e.get('val'),
            l = this.styles.clrScheme.find((e) => {
              const l = e.getInnerElements('a:sysClr|a:srgbClr')[0];
              return (
                !!e.container.includes(t) ||
                ('tx1' === t
                  ? 'windowText' === l.get('val')
                  : 'bg1' === t && 'window' === l.get('val'))
              );
            });
          let n = '#000000';
          l && (n = this.getThemColor(l));
          const r = e.getInnerElements('a:lumMod')?.[0]?.get('val'),
            i = e.getInnerElements('a:lumOff')?.[0]?.get('val');
          return `rgb(${G(n)
            .map((e) => {
              const t = r ? (e * parseInt(r)) / 1e5 : e,
                l = i ? Math.round((parseInt(i) / 1e5) * 255) : 0;
              return Math.round(t + l);
            })
            .join(',')})`;
        }),
        (this.getThemColor = (e) => {
          let t = '#000000';
          const l = e.getInnerElements('a:sysClr|a:srgbClr');
          if (null != l) {
            const e = l[0],
              n = e.attributeList;
            e.container.indexOf('sysClr') > -1
              ? null != n.lastClr
                ? (t = '#' + n.lastClr)
                : null != n.val && (t = '#' + n.val)
              : e.container.indexOf('srgbClr') > -1 && (t = '#' + n.val);
          }
          return t;
        }),
        (this.getContext = () => ({
          categoryIndex: 0,
          seriesIndexes: this.readXml.getElementsByTagName('c:ser', this.chartFile).map((e) => {
            const t = e.getInnerElements('c:idx')[0];
            return parseInt(t.get('val')) + 1;
          }),
        }));
      const { id: t, range: l, chartType: n, chartFile: r, readXml: i, image: a, styles: s } = e;
      (this.styles = s),
        (this.range = l),
        (this.chartType = n),
        (this.readXml = i),
        (this.chartFile = r),
        (this.isRowDirection = !0),
        (this.id = t),
        (this.context = this.getContext()),
        (this.style = this.getStyle(a));
    }
    get model() {
      return {
        id: this.id,
        range: this.range,
        chartType: this.chartType,
        context: this.context,
        style: this.style,
        isRowDirection: this.isRowDirection,
      };
    }
  }
  class Ze extends me {
    constructor(e, t, l, n = !1, r) {
      super(),
        (this.getImageBaseInfo = (e, t) => {
          let l = this.readXml.getElementsByTagName('xdr:twoCellAnchor', e),
            n = this.readXml.getElementsByTagName('xdr:oneCellAnchor', e);
          if (((l = [...l, ...n]), null != l && l.length > 0))
            for (let e = 0; e < l.length; e++) {
              let n = l[e],
                r = n.getInnerElements('xdr:from'),
                i = n.getInnerElements('xdr:to');
              if (null != r && r.length > 0) {
                let e,
                  l,
                  a = r[0];
                i ? (e = i[0]) : (l = n.getInnerElements('xdr:ext')[0]);
                let s = n.getInnerElements('xdr:graphicFrame')
                    ? this.getGraphic(n, t)
                    : this.getImage(n, t),
                  o = 0,
                  c = 0,
                  u = 0,
                  h = 0;
                if (
                  ((s.fromCol = this.getXdrValue(a.getInnerElements('xdr:col'))),
                  (s.fromColOff = B(this.getXdrValue(a.getInnerElements('xdr:colOff')))),
                  (s.fromRow = this.getXdrValue(a.getInnerElements('xdr:row'))),
                  (s.fromRowOff = B(this.getXdrValue(a.getInnerElements('xdr:rowOff')))),
                  e)
                )
                  (s.toCol = this.getXdrValue(e.getInnerElements('xdr:col'))),
                    (s.toColOff = B(this.getXdrValue(e.getInnerElements('xdr:colOff')))),
                    (s.toRow = this.getXdrValue(e.getInnerElements('xdr:row'))),
                    (s.toRowOff = B(this.getXdrValue(e.getInnerElements('xdr:rowOff'))));
                else {
                  let e = l.attributeList;
                  (u = B(parseInt(e.cx))),
                    (h = B(parseInt(e.cy))),
                    (s.toCol = s.fromCol),
                    (s.toColOff = Number(s.fromColOff) + u),
                    (s.toRow = s.fromRow),
                    (s.toRowOff = Number(s.fromRowOff) + h);
                }
                (s.originWidth = u),
                  (s.originHeight = h),
                  (s.isFixedPos = !1),
                  (s.fixedLeft = 0),
                  (s.fixedTop = 0);
                let f = { color: '#000', radius: 0, style: 'solid', width: 0 };
                s.border = f;
                let g = { height: h, offsetLeft: 0, offsetTop: 0, width: u };
                s.crop = g;
                let d = { height: h, left: o, top: c, width: u };
                (s.default = d),
                  null == this.images && (this.images = {}),
                  (this.images[s.id || V('image')] = s);
              }
            }
          return null;
        }),
        (this.getImage = (e, t) => {
          let l = e.getInnerElements('a:blip'),
            n = k(e.attributeList, 'editAs', 'twoCell');
          if (null != l && l.length > 0) {
            let e = k(l[0].attributeList, 'r:embed', null),
              r = this.getBase64ByRid(e, t);
            return (r.type = 'absolute' == n ? '3' : 'oneCell' == n ? '2' : '1'), r;
          }
          return {};
        }),
        (this.getGraphic = (e, t) => {
          const l = e.getInnerElements('xdr:graphicFrame');
          if (l.length) {
            const e = l[0],
              n = new Ye({
                graphicFrame: e,
                readXml: this.readXml,
                drawingRelsFile: t,
                styles: this.styles,
              }),
              r = n.image;
            return (
              n.chart && (null == this.charts && (this.charts = []), this.charts.push(n.chart)), r
            );
          }
          return {};
        }),
        (this.getCellSize = (e) => {
          let t = e.attributeList,
            l = t.r;
          t.s, t.t;
          let n = M(l);
          const r = n.row[0],
            i = n.column[0];
          return {
            width:
              this.config.columnlen && this.config.columnlen[i]
                ? this.config.columnlen[i]
                : this.defaultColWidth,
            height:
              this.config.rowlen && this.config.rowlen[r]
                ? this.config.rowlen[r]
                : this.defaultRowHeight,
          };
        }),
        (this.isInitialCell = n),
        (this.readXml = r.readXml),
        (this.sheetFile = r.sheetFile),
        (this.styles = r.styles),
        (this.sharedStrings = r.sharedStrings),
        (this.calcChainEles = r.calcChain),
        (this.sheetList = r.sheetList),
        (this.imageList = r.imageList),
        (this.hide = r.hide),
        (this.cellImages = r.cellImages),
        (this.name = e),
        (this.index = t),
        (this.order = l.toString()),
        (this.config = new ve()),
        (this.celldata = []),
        (this.mergeCells = this.readXml.getElementsByTagName(
          'mergeCells/mergeCell',
          this.sheetFile,
        )),
        this.styles.clrScheme;
      let i = this.readXml.getElementsByTagName('sheetViews/sheetView', this.sheetFile),
        a = '1',
        s = '0',
        o = '100',
        c = 'A1';
      if (i.length > 0) {
        let e = i[0].attributeList;
        (a = k(e, 'showGridLines', '1')),
          (s = k(e, 'tabSelected', '0')),
          (o = k(e, 'zoomScale', '100'));
        let t = i[0].getInnerElements('selection');
        if (null != t && t.length > 0) {
          c = k(t[0].attributeList, 'activeCell', 'A1');
          let e = M(c);
          (this.luckysheet_select_save = []), this.luckysheet_select_save.push(e);
        }
        let l = i[0].getInnerElements('pane');
        l?.length > 0 && (this.freezen = new qe(l[0]));
      }
      (this.showGridLines = a), (this.status = s), (this.zoomRatio = parseInt(o) / 100);
      let u = this.readXml.getElementsByTagName('sheetPr/tabColor', this.sheetFile);
      if (null != u && u.length > 0) {
        let e = u[0];
        e.attributeList;
        let t = he(e, this.styles, 'b');
        this.color = t;
      }
      let h,
        f,
        g = this.readXml.getElementsByTagName('sheetFormatPr', this.sheetFile);
      if (g.length > 0) {
        let e = g[0].attributeList;
        (h = k(e, 'defaultColWidth', '9.21')), (f = k(e, 'defaultRowHeight', '19'));
      }
      (this.defaultColWidth = _(parseFloat(h))),
        (this.defaultRowHeight = D(parseFloat(f))),
        this.generateConfigColumnLenAndHidden();
      let d = this.generateConfigRowLenAndHiddenAddCell();
      null == this.calcChain && (this.calcChain = []);
      let m = {};
      for (let e = 0; e < this.calcChainEles.length; e++) {
        let l = this.calcChainEles[e].attributeList;
        if (l.i != t) continue;
        let n = l.r;
        l.i, l.l, l.s, l.a, l.t;
        let r = M(n),
          i = new Le();
        (i.r = r.row[0]),
          (i.c = r.column[0]),
          (i.index = this.index),
          this.calcChain.push(i),
          (m['r' + n + 'c' + e] = null);
      }
      if (null != this.formulaRefList)
        for (let e in this.formulaRefList) {
          let t = this.formulaRefList[e],
            l = t.mainRef,
            n = l.cellValue,
            r = l.fv,
            i = n.r,
            a = n.c;
          for (let e in t) {
            if ('mainRef' == e) continue;
            let l = t[e].cellValue;
            if (null == l) continue;
            let n = r,
              s = l.r - i,
              o = l.c - a;
            s > 0
              ? (n = '=' + H.functionCopy(n, 'down', s))
              : s < 0 && (n = '=' + H.functionCopy(n, 'up', Math.abs(s))),
              o > 0
                ? (n = '=' + H.functionCopy(n, 'right', o))
                : o < 0 && (n = '=' + H.functionCopy(n, 'left', Math.abs(o))),
              (l.v.f = n);
            let c = new Le();
            (c.r = l.r), (c.c = l.c), (c.index = this.index), this.calcChain.push(c);
          }
        }
      for (let e in d.formulaList)
        if (!(e in m)) {
          let t = d.formulaList[e],
            l = new Le();
          (l.r = t.r), (l.c = t.c), (l.index = this.index), this.calcChain.push(l);
        }
      const p = this.readXml.getElementsByTagName('conditionalFormatting', this.sheetFile),
        E =
          this.readXml.getElementsByTagName(
            'extLst/ext/x14:conditionalFormattings/x14:conditionalFormatting',
            this.sheetFile,
          ) || [],
        b =
          E?.map((e) => {
            const t = this.readXml.getElementsByTagName('xm:sqref', e.value, !1)?.[0];
            return this.readXml
              .getElementsByTagName('x14:cfRule', e.value, !1)
              .map((e) => ({
                ...e,
                parentAttribute: { sqref: t?.value },
                isExtLst: !0,
                extLst: void 0,
              }));
          })?.flat() || [];
      if (p?.length) {
        const e =
          p
            .map((e) =>
              this.readXml
                .getElementsByTagName('cfRule', e.value, !1)
                ?.map((t) => ({
                  ...t,
                  parentAttribute: e.attributeList,
                  extLst: b.find((t) => t.parentAttribute.sqref === e.attributeList?.sqref),
                })),
            )
            ?.flat()
            .filter(Boolean)
            .concat(
              b?.filter(
                (e) => -1 === p.findIndex((t) => t.attributeList.sqref === e.parentAttribute.sqref),
              ),
            ) || [];
        this.conditionalFormatting = e.map((e) => new We(e, this.readXml, this.styles));
      }
      const T = new ze(this.readXml, this.sheetFile);
      if (
        (T.ref && (this.filter = T),
        (this.dataVerification = this.generateConfigDataValidations()),
        (this.dataVerificationList = this.generateConfigDataValidationsList()),
        (this.hyperlink = this.generateConfigHyperlinks()),
        (this.hide = this.hide),
        null != this.mergeCells)
      )
        for (let e = 0; e < this.mergeCells.length; e++) {
          let t = this.mergeCells[e].attributeList.ref;
          if (null == t) continue;
          let l = M(t),
            n = new Re();
          (n.r = l.row[0]),
            (n.c = l.column[0]),
            (n.rs = l.row[1] - l.row[0] + 1),
            (n.cs = l.column[1] - l.column[0] + 1),
            null == this.config.merge && (this.config.merge = {}),
            (this.config.merge[l.row[0] + '_' + l.column[0]] = n);
        }
      let y = r.drawingFile,
        v = r.drawingRelsFile;
      null != y && null != v && this.getImageBaseInfo(y, v);
    }
    getXdrValue(e) {
      return null == e || 0 == e.length ? null : parseInt(e[0].value);
    }
    getBase64ByRid(e, t) {
      let l = this.readXml.getElementsByTagName('Relationships/Relationship', t);
      if (null != l && l.length > 0)
        for (let t = 0; t < l.length; t++) {
          let n = l[t].attributeList,
            r = k(n, 'Id', null),
            i = k(n, 'Target', null);
          if (r == e) {
            return (
              (i = i.replace(/\.\.\//g, '')), (i = 'xl/' + i), this.imageList.getImageByName(i)
            );
          }
        }
      return {};
    }
    generateConfigColumnLenAndHidden() {
      let e = this.readXml.getElementsByTagName('cols/col', this.sheetFile);
      for (let t = 0; t < e.length; t++) {
        let l = e[t].attributeList,
          n = k(l, 'min', null),
          r = k(l, 'max', null),
          i = k(l, 'width', null),
          a = k(l, 'hidden', null),
          s = k(l, 'customWidth', null);
        if (null == n || null == r) continue;
        let o = parseInt(n) - 1,
          c = parseInt(r) - 1,
          u = parseFloat(i);
        for (let e = o; e <= c; e++)
          null != i &&
            (null == this.config.columnlen && (this.config.columnlen = {}),
            (this.config.columnlen[e] = _(u))),
            '1' == a &&
              (null == this.config.colhidden && (this.config.colhidden = {}),
              (this.config.colhidden[e] = 0),
              this.config.columnlen && delete this.config.columnlen[e]),
            null != s &&
              (null == this.config.customWidth && (this.config.customWidth = {}),
              (this.config.customWidth[e] = 1));
      }
    }
    generateConfigRowLenAndHiddenAddCell() {
      let e = this.readXml.getElementsByTagName('sheetData/row', this.sheetFile),
        t = {};
      t.formulaList = {};
      for (let l = 0; l < e.length; l++) {
        let n = e[l],
          r = n.attributeList,
          i = k(r, 'r', null),
          a = k(r, 'ht', null),
          s = k(r, 'hidden', null),
          o = k(r, 'customHeight', null);
        if (null == i) continue;
        let c = parseInt(i) - 1;
        if (null != a) {
          let e = parseFloat(a);
          null == this.config.rowlen && (this.config.rowlen = {}), (this.config.rowlen[c] = D(e));
        }
        if (
          ('1' == s &&
            (null == this.config.rowhidden && (this.config.rowhidden = {}),
            (this.config.rowhidden[c] = 0),
            this.config.rowlen && delete this.config.rowlen[c]),
          null != o &&
            (null == this.config.customHeight && (this.config.customHeight = {}),
            (this.config.customHeight[c] = 1)),
          this.isInitialCell)
        ) {
          let e = n.getInnerElements('c');
          for (let l in e) {
            let n = e[l];
            const r = this.getCellSize(n);
            let i = new ke(
              n,
              r,
              this.styles,
              this.sharedStrings,
              this.mergeCells,
              this.sheetFile,
              this.cellImages,
              this.imageList,
              this.readXml,
            );
            if (
              (null != i._borderObject &&
                (null == this.config.borderInfo && (this.config.borderInfo = []),
                this.config.borderInfo.push(i._borderObject),
                delete i._borderObject),
              'shared' == i._formulaType)
            ) {
              let e;
              null == this.formulaRefList && (this.formulaRefList = {}),
                null == this.formulaRefList[i._formulaSi] &&
                  (this.formulaRefList[i._formulaSi] = {}),
                null != i.v && (e = i.v.f);
              let t = {
                t: i._formulaType,
                ref: i._fomulaRef,
                si: i._formulaSi,
                fv: e,
                cellValue: i,
              };
              null != i._fomulaRef
                ? (this.formulaRefList[i._formulaSi].mainRef = t)
                : (this.formulaRefList[i._formulaSi][i.r + '_' + i.c] = t);
            }
            if (null != i.v && null != i.v.f) {
              let e = { r: i.r, c: i.c };
              t.formulaList['r' + i.r + 'c' + i.c] = e;
            }
            this.celldata.push(i);
          }
        }
      }
      return t;
    }
    generateConfigDataValidationsList() {
      let e = this.readXml.getElementsByTagName('dataValidations/dataValidation', this.sheetFile),
        t =
          this.readXml.getElementsByTagName(
            'extLst/ext/x14:dataValidations/x14:dataValidation',
            this.sheetFile,
          ) || [];
      return (e = e.concat(t)), e.map((e) => new He(e, t)).filter((e) => e.uid);
    }
    generateConfigDataValidations() {
      let e = this.readXml.getElementsByTagName('dataValidations/dataValidation', this.sheetFile),
        t =
          this.readXml.getElementsByTagName(
            'extLst/ext/x14:dataValidations/x14:dataValidation',
            this.sheetFile,
          ) || [];
      e = e.concat(t);
      let l = {};
      for (let n = 0; n < e.length; n++) {
        let r = e[n],
          i = r.attributeList,
          a = r.value,
          o = k(i, 'type', null);
        if (!o) continue;
        let c = '',
          u = '',
          h = [],
          f = [],
          g = '1' === k(i, 'allowBlank', null);
        if (new RegExp(/<x14:formula1>|<xm:sqref>/g).test(a) && t?.length >= 0) {
          c = k(i, 'operator', null);
          const e = $(a);
          (u = e?.sqref), (h = U(u)), (f = Z(e?.formula));
        } else (c = k(i, 'operator', null)), (u = k(i, 'sqref', null)), (h = U(u)), (f = Z(a));
        let d = R[o],
          m = null,
          p = f?.length >= 1 ? f[0] : '',
          E = 2 === f?.length ? f[1] : '',
          b = k(i, 'prompt', null),
          T = !!b;
        const y = L.includes(d) || !S[d] ? 'common' : d;
        if (
          ((m = c ? S[y][c] : 'bw'),
          'text_content' === d &&
            (p?.includes('LEN') || p?.includes('len')) &&
            p?.includes('=11') &&
            ((d = 'validity'), (m = 'phone')),
          'date' === d)
        ) {
          const e = new Date(1899, 11, 30, 0, 0, 0);
          (p = s.default(e).clone().add(Number(p), 'day').format('YYYY-MM-DD')),
            (E = s.default(e).clone().add(Number(E), 'day').format('YYYY-MM-DD'));
        }
        ('checkbox' !== d && 'dropdown' !== d) || (m = null);
        for (const e of h)
          l[e] = {
            type: d,
            type2: m,
            value1: p,
            value2: E,
            checked: !1,
            remote: !1,
            prohibitInput: g,
            hintShow: T,
            hintText: b,
          };
      }
      return l;
    }
    generateConfigHyperlinks() {
      let e = this.readXml.getElementsByTagName('hyperlinks/hyperlink', this.sheetFile),
        t = {};
      for (let l = 0; l < e.length; l++) {
        let n = e[l].attributeList,
          r = U(k(n, 'ref', null)),
          i = k(n, 'display', null),
          a = k(n, 'location', null),
          s = k(n, 'tooltip', null),
          o = a ? 'internal' : 'external';
        if (!a) {
          let e = n['r:id'],
            t = this.sheetFile,
            l = this.readXml.getElementsByTagName(
              'Relationships/Relationship',
              `xl/worksheets/_rels/${t.replace('xl/worksheets/', '')}.rels`,
            );
          const r = l?.find((t) => t.attributeList.Id === e);
          r &&
            ((a = r.attributeList.Target), (o = r.attributeList.TargetMode?.toLocaleLowerCase()));
        }
        new RegExp(/^.*!R([\d$])+C([\d$])*$/g).test(a) && (a = Y(a));
        for (const e of r)
          t[e] = { linkAddress: a, linkTooltip: s || '', linkType: o, display: i || '' };
      }
      return t;
    }
  }
  let Je = {};
  (Je.G = {
    concat: function (e, t) {
      for (var l = 0; l < t.cmds.length; l++) e.cmds.push(t.cmds[l]);
      for (l = 0; l < t.crds.length; l++) e.crds.push(t.crds[l]);
    },
    getBB: function (e) {
      for (var t = 1e99, l = 1e99, n = -t, r = -l, i = 0; i < e.length; i += 2) {
        var a = e[i],
          s = e[i + 1];
        a < t ? (t = a) : a > n && (n = a), s < l ? (l = s) : s > r && (r = s);
      }
      return [t, l, n, r];
    },
    rectToPath: function (e) {
      return {
        cmds: ['M', 'L', 'L', 'L', 'Z'],
        crds: [e[0], e[1], e[2], e[1], e[2], e[3], e[0], e[3]],
      };
    },
    insideBox: function (e, t) {
      return t[0] <= e[0] && t[1] <= e[1] && e[2] <= t[2] && e[3] <= t[3];
    },
    isBox: function (e, t) {
      var l = function (e, t) {
        for (var l = 0; l < 8; l += 2) {
          for (var n = !0, r = 0; r < 8; r++)
            if (Math.abs(t[r] - e[(r + l) & 7]) >= 2) {
              n = !1;
              break;
            }
          if (n) return !0;
        }
        return !1;
      };
      if (e.cmds.length > 10) return !1;
      var n = e.cmds.join(''),
        r = e.crds,
        i = !1;
      if (('MLLLZ' == n && 8 == r.length) || ('MLLLLZ' == n && 10 == r.length)) {
        10 == r.length && (r = r.slice(0, 8));
        var a = t[0],
          s = t[1],
          o = t[2],
          c = t[3];
        i || (i = l(r, [a, s, o, s, o, c, a, c])), i || (i = l(r, [a, c, o, c, o, s, a, s]));
      }
      return i;
    },
    boxArea: function (e) {
      return (e[2] - e[0]) * (e[3] - e[1]);
    },
    newPath: function (e) {
      e.pth = { cmds: [], crds: [] };
    },
    moveTo: function (e, t, l) {
      var n = Je.M.multPoint(e.ctm, [t, l]);
      e.pth.cmds.push('M'), e.pth.crds.push(n[0], n[1]), (e.cpos = n);
    },
    lineTo: function (e, t, l) {
      var n = Je.M.multPoint(e.ctm, [t, l]);
      (e.cpos[0] == n[0] && e.cpos[1] == n[1]) ||
        (e.pth.cmds.push('L'), e.pth.crds.push(n[0], n[1]), (e.cpos = n));
    },
    curveTo: function (e, t, l, n, r, i, a) {
      var s;
      (t = (s = Je.M.multPoint(e.ctm, [t, l]))[0]),
        (l = s[1]),
        (n = (s = Je.M.multPoint(e.ctm, [n, r]))[0]),
        (r = s[1]),
        (i = (s = Je.M.multPoint(e.ctm, [i, a]))[0]),
        (a = s[1]),
        (e.cpos = s),
        e.pth.cmds.push('C'),
        e.pth.crds.push(t, l, n, r, i, a);
    },
    closePath: function (e) {
      e.pth.cmds.push('Z');
    },
    arc: function (e, t, l, n, r, i, a) {
      if (a) for (; i > r; ) i -= 2 * Math.PI;
      else for (; i < r; ) i += 2 * Math.PI;
      var s = (i - r) / 4,
        o = Math.cos(s / 2),
        c = -Math.sin(s / 2),
        u = (4 - o) / 3,
        h = 0 == c ? c : ((1 - o) * (3 - o)) / (3 * c),
        f = u,
        g = -h,
        d = o,
        m = -c,
        p = [u, h],
        E = [f, g],
        b = [d, m],
        T = {
          cmds: [0 == e.pth.cmds.length ? 'M' : 'L', 'C', 'C', 'C', 'C'],
          crds: [o, c, u, h, f, g, d, m],
        },
        y = [1, 0, 0, 1, 0, 0];
      Je.M.rotate(y, -s);
      for (var v = 0; v < 3; v++)
        (p = Je.M.multPoint(y, p)),
          (E = Je.M.multPoint(y, E)),
          (b = Je.M.multPoint(y, b)),
          T.crds.push(p[0], p[1], E[0], E[1], b[0], b[1]);
      var w = [n, 0, 0, n, t, l];
      Je.M.rotate(y, s / 2 - r),
        Je.M.concat(y, w),
        Je.M.multArray(y, T.crds),
        Je.M.multArray(e.ctm, T.crds),
        Je.G.concat(e.pth, T);
      l = T.crds.pop();
      (t = T.crds.pop()), (e.cpos = [t, l]);
    },
    toPoly: function (e) {
      if ('M' != e.cmds[0] || 'Z' != e.cmds[e.cmds.length - 1]) return null;
      for (var t = 1; t < e.cmds.length - 1; t++) if ('L' != e.cmds[t]) return null;
      var l = [],
        n = e.crds.length;
      e.crds[0] == e.crds[n - 2] && e.crds[1] == e.crds[n - 1] && (n -= 2);
      for (t = 0; t < n; t += 2) l.push([e.crds[t], e.crds[t + 1]]);
      return Je.G.polyArea(e.crds) < 0 && l.reverse(), l;
    },
    fromPoly: function (e) {
      for (var t = { cmds: [], crds: [] }, l = 0; l < e.length; l++)
        t.crds.push(e[l][0], e[l][1]), t.cmds.push(0 == l ? 'M' : 'L');
      return t.cmds.push('Z'), t;
    },
    polyArea: function (e) {
      if (e.length < 6) return 0;
      for (var t = e.length - 2, l = (e[0] - e[t]) * (e[t + 1] + e[1]), n = 0; n < t; n += 2)
        l += (e[n + 2] - e[n]) * (e[n + 1] + e[n + 3]);
      return 0.5 * -l;
    },
    polyClip: function (e, t) {
      var l,
        n,
        r = function (e) {
          return (s[0] - l[0]) * (e[1] - l[1]) > (s[1] - l[1]) * (e[0] - l[0]);
        },
        i = function () {
          var e = [l[0] - s[0], l[1] - s[1]],
            t = [n[0] - c[0], n[1] - c[1]],
            r = l[0] * s[1] - l[1] * s[0],
            i = n[0] * c[1] - n[1] * c[0],
            a = 1 / (e[0] * t[1] - e[1] * t[0]);
          return [(r * t[0] - i * e[0]) * a, (r * t[1] - i * e[1]) * a];
        },
        a = e;
      l = t[t.length - 1];
      for (let e in t) {
        var s = t[e],
          o = a;
        (a = []), (n = o[o.length - 1]);
        for (let e in o) {
          var c;
          r((c = o[e])) ? (r(n) || a.push(i()), a.push(c)) : r(n) && a.push(i()), (n = c);
        }
        l = s;
      }
      return a;
    },
  }),
    (Je.M = {
      getScale: function (e) {
        return Math.sqrt(Math.abs(e[0] * e[3] - e[1] * e[2]));
      },
      translate: function (e, t, l) {
        Je.M.concat(e, [1, 0, 0, 1, t, l]);
      },
      rotate: function (e, t) {
        Je.M.concat(e, [Math.cos(t), -Math.sin(t), Math.sin(t), Math.cos(t), 0, 0]);
      },
      scale: function (e, t, l) {
        Je.M.concat(e, [t, 0, 0, l, 0, 0]);
      },
      concat: function (e, t) {
        var l = e[0],
          n = e[1],
          r = e[2],
          i = e[3],
          a = e[4],
          s = e[5];
        (e[0] = l * t[0] + n * t[2]),
          (e[1] = l * t[1] + n * t[3]),
          (e[2] = r * t[0] + i * t[2]),
          (e[3] = r * t[1] + i * t[3]),
          (e[4] = a * t[0] + s * t[2] + t[4]),
          (e[5] = a * t[1] + s * t[3] + t[5]);
      },
      invert: function (e) {
        var t = e[0],
          l = e[1],
          n = e[2],
          r = e[3],
          i = e[4],
          a = e[5],
          s = t * r - l * n;
        (e[0] = r / s),
          (e[1] = -l / s),
          (e[2] = -n / s),
          (e[3] = t / s),
          (e[4] = (n * a - r * i) / s),
          (e[5] = (l * i - t * a) / s);
      },
      multPoint: function (e, t) {
        var l = t[0],
          n = t[1];
        return [l * e[0] + n * e[2] + e[4], l * e[1] + n * e[3] + e[5]];
      },
      multArray: function (e, t) {
        for (var l = 0; l < t.length; l += 2) {
          var n = t[l],
            r = t[l + 1];
          (t[l] = n * e[0] + r * e[2] + e[4]), (t[l + 1] = n * e[1] + r * e[3] + e[5]);
        }
      },
    }),
    (Je.C = {
      srgbGamma: function (e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055;
      },
      cmykToRgb: function (e) {
        var t = e[0],
          l = e[1],
          n = e[2],
          r = e[3],
          i =
            255 +
            t *
              (-4.387332384609988 * t +
                54.48615194189176 * l +
                18.82290502165302 * n +
                212.25662451639585 * r -
                285.2331026137004) +
            l *
              (1.7149763477362134 * l -
                5.6096736904047315 * n +
                -17.873870861415444 * r -
                5.497006427196366) +
            n * (-2.5217340131683033 * n - 21.248923337353073 * r + 17.5119270841813) +
            r * (-21.86122147463605 * r - 189.48180835922747),
          a =
            255 +
            t *
              (8.841041422036149 * t +
                60.118027045597366 * l +
                6.871425592049007 * n +
                31.159100130055922 * r -
                79.2970844816548) +
            l *
              (-15.310361306967817 * l +
                17.575251261109482 * n +
                131.35250912493976 * r -
                190.9453302588951) +
            n * (4.444339102852739 * n + 9.8632861493405 * r - 24.86741582555878) +
            r * (-20.737325471181034 * r - 187.80453709719578),
          s =
            255 +
            t *
              (0.8842522430003296 * t +
                8.078677503112928 * l +
                30.89978309703729 * n -
                0.23883238689178934 * r -
                14.183576799673286) +
            l *
              (10.49593273432072 * l +
                63.02378494754052 * n +
                50.606957656360734 * r -
                112.23884253719248) +
            n * (0.03296041114873217 * n + 115.60384449646641 * r - 193.58209356861505) +
            r * (-22.33816807309886 * r - 180.12613974708367);
        return [
          Math.max(0, Math.min(1, i / 255)),
          Math.max(0, Math.min(1, a / 255)),
          Math.max(0, Math.min(1, s / 255)),
        ];
      },
      labToRgb: function (e) {
        for (
          var t = 903.3,
            l = 0.008856,
            n = e[0],
            r = e[1],
            i = (n + 16) / 116,
            a = i * i * i,
            s = i - e[2] / 200,
            o = s * s * s,
            c = r / 500 + i,
            u = c * c * c,
            h = [
              (96.72 * (u > l ? u : (116 * c - 16) / t)) / 100,
              (100 * (a > l ? a : (116 * i - 16) / t)) / 100,
              (81.427 * (o > l ? o : (116 * s - 16) / t)) / 100,
            ],
            f = [
              3.1338561, -1.6168667, -0.4906146, -0.9787684, 1.9161415, 0.033454, 0.0719453,
              -0.2289914, 1.4052427,
            ],
            g = [
              f[0] * h[0] + f[1] * h[1] + f[2] * h[2],
              f[3] * h[0] + f[4] * h[1] + f[5] * h[2],
              f[6] * h[0] + f[7] * h[1] + f[8] * h[2],
            ],
            d = 0;
          d < 3;
          d++
        )
          g[d] = Math.max(0, Math.min(1, Je.C.srgbGamma(g[d])));
        return g;
      },
    }),
    (Je.getState = function (e) {
      return {
        font: Je.getFont(),
        dd: { flat: 1 },
        space: '/DeviceGray',
        ca: 1,
        colr: [0, 0, 0],
        sspace: '/DeviceGray',
        CA: 1,
        COLR: [0, 0, 0],
        bmode: '/Normal',
        SA: !1,
        OPM: 0,
        AIS: !1,
        OP: !1,
        op: !1,
        SMask: '/None',
        lwidth: 1,
        lcap: 0,
        ljoin: 0,
        mlimit: 10,
        SM: 0.1,
        doff: 0,
        dash: [],
        ctm: [1, 0, 0, 1, 0, 0],
        cpos: [0, 0],
        pth: { cmds: [], crds: [] },
        cpth: e ? Je.G.rectToPath(e) : null,
      };
    }),
    (Je.getFont = function () {
      return {
        Tc: 0,
        Tw: 0,
        Th: 100,
        Tl: 0,
        Tf: 'Helvetica-Bold',
        Tfs: 1,
        Tmode: 0,
        Trise: 0,
        Tk: 0,
        Tal: 0,
        Tun: 0,
        Tm: [1, 0, 0, 1, 0, 0],
        Tlm: [1, 0, 0, 1, 0, 0],
        Trm: [1, 0, 0, 1, 0, 0],
      };
    });
  let Ke = function () {};
  (Ke.Parse = function (e, t) {
    e = new Uint8Array(e);
    for (
      var l,
        n = 0,
        r = {
          fill: !1,
          strk: !1,
          bb: [0, 0, 1, 1],
          wbb: [0, 0, 1, 1],
          fnt: { nam: 'Arial', hgh: 25, und: !1, orn: 0 },
          tclr: [0, 0, 0],
          talg: 0,
        },
        i = [],
        a = [],
        s = Ke.B.readShort,
        o = Ke.B.readUshort,
        c = Ke.B.readInt,
        u = Ke.B.readUint,
        h = Ke.B.readFloat;
      ;

    ) {
      var f = u(e, n);
      n += 4;
      var g = Ke.K[f],
        d = u(e, n),
        m = (n += 4),
        p = null,
        E = 0;
      if ('EOF' == g) break;
      if ('HEADER' == g)
        (r.bb = Ke._readBox(e, m)),
          (m += 16),
          t.StartPage(r.bb[0], r.bb[1], r.bb[2], r.bb[3]),
          (l = Je.getState(r.bb));
      else if ('SAVEDC' == g) a.push(JSON.stringify(l), JSON.stringify(r));
      else if ('RESTOREDC' == g) {
        var b = c(e, m);
        for (m += 4; b < -1; ) a.pop(), a.pop();
        (r = JSON.parse(a.pop())), (l = JSON.parse(a.pop()));
      } else if ('SELECTCLIPPATH' == g) l.cpth = JSON.parse(JSON.stringify(l.pth));
      else if (
        -1 !=
        [
          'SETMAPMODE',
          'SETPOLYFILLMODE',
          'SETBKMODE',
          'SETICMMODE',
          'SETROP2',
          'EXTSELECTCLIPRGN',
        ].indexOf(g)
      );
      else if ('SETMITERLIMIT' == g) l.mlimit = u(e, m);
      else if ('SETTEXTCOLOR' == g) r.tclr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255];
      else if ('SETTEXTALIGN' == g) r.talg = u(e, m);
      else if ('SETVIEWPORTEXTEX' == g || 'SETVIEWPORTORGEX' == g) {
        null == r.vbb && (r.vbb = []);
        var T = 'SETVIEWPORTORGEX' == g ? 0 : 2;
        (r.vbb[T] = c(e, m)),
          (m += 4),
          (r.vbb[T + 1] = c(e, m)),
          (m += 4),
          'SETVIEWPORTEXTEX' == g && Ke._updateCtm(r, l);
      } else if ('SETWINDOWEXTEX' == g || 'SETWINDOWORGEX' == g) {
        T = 'SETWINDOWORGEX' == g ? 0 : 2;
        (r.wbb[T] = c(e, m)),
          (m += 4),
          (r.wbb[T + 1] = c(e, m)),
          (m += 4),
          'SETWINDOWEXTEX' == g && Ke._updateCtm(r, l);
      } else if ('COMMENT' == g) u(e, m), (m += 4);
      else if ('SELECTOBJECT' == g) {
        var y = u(e, m);
        if (((m += 4), 2147483648 == y)) (r.fill = !0), (l.colr = [1, 1, 1]);
        else if (2147483653 == y) r.fill = !1;
        else if (2147483655 == y) (r.strk = !0), (r.lwidth = 1), (l.COLR = [0, 0, 0]);
        else if (2147483656 == y) r.strk = !1;
        else if (2147483661 == y);
        else if (2147483662 == y);
        else {
          var v = i[y];
          if ('b' == v.t) {
            if (((r.fill = 1 != v.stl), 0 == v.stl));
            else if (1 != v.stl) throw v.stl + ' e';
            l.colr = v.clr;
          } else if ('p' == v.t) (r.strk = 5 != v.stl), (l.lwidth = v.wid), (l.COLR = v.clr);
          else {
            if ('f' != v.t) throw 'e';
            (r.fnt = v), (l.font.Tf = v.nam), (l.font.Tfs = Math.abs(v.hgh)), (l.font.Tun = v.und);
          }
        }
      } else if ('DELETEOBJECT' == g) {
        y = u(e, m);
        if (((m += 4), null == i[y])) throw 'e';
        i[y] = null;
      } else if ('CREATEBRUSHINDIRECT' == g)
        (E = u(e, m)),
          ((p = { t: 'b' }).stl = u(e, (m += 4))),
          (m += 4),
          (p.clr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255]),
          (m += 4),
          (p.htc = u(e, m)),
          (m += 4);
      else if ('CREATEPEN' == g || 'EXTCREATEPEN' == g)
        (E = u(e, m)),
          (m += 4),
          (p = { t: 'p' }),
          'EXTCREATEPEN' == g
            ? ((m += 16), (p.stl = u(e, m)), (m += 4), (p.wid = u(e, m)), (m += 4), (m += 4))
            : ((p.stl = u(e, m)), (m += 4), (p.wid = u(e, m)), (m += 4), (m += 4)),
          (p.clr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255]),
          (m += 4);
      else if ('EXTCREATEFONTINDIRECTW' == g) {
        (E = u(e, m)),
          ((p = { t: 'f', nam: '' }).hgh = c(e, (m += 4))),
          (m += 4),
          (m += 8),
          (p.orn = c(e, m) / 10);
        var w = u(e, (m += 4));
        for (m += 4, p.und = e[m + 1], p.stk = e[m + 2], m += 8; 0 != o(e, m); )
          (p.nam += String.fromCharCode(o(e, m))), (m += 2);
        w > 500 && (p.nam += '-Bold');
      } else if ('EXTTEXTOUTW' == g) {
        var I = u(e, (m += 16));
        h(e, (m += 4)), h(e, (m += 4));
        var C = c(e, (m += 4)),
          R = c(e, (m += 4));
        (m += 4),
          (l.font.Tm = [1, 0, 0, -1, 0, 0]),
          Je.M.rotate(l.font.Tm, (r.fnt.orn * Math.PI) / 180),
          Je.M.translate(l.font.Tm, C, R);
        var L = r.talg;
        if (6 & ~L) {
          if (7 & L) throw L + ' e';
          l.font.Tal = 0;
        } else l.font.Tal = 2;
        if (24 & ~L) {
          if (24 & L) throw 'e';
          Je.M.translate(l.font.Tm, 0, l.font.Tfs);
        } else;
        var S = u(e, m),
          x = u(e, (m += 4));
        u(e, (m += 4)), (m += 4), u(e, (m += 16)), (m += 4), (x += n - 8);
        for (var N = '', O = 0; O < S; O++) {
          var M = o(e, x + 2 * O);
          N += String.fromCharCode(M);
        }
        var A = l.colr;
        (l.colr = r.tclr), t.PutText(l, N, N.length * l.font.Tfs * 0.5), (l.colr = A);
      } else if ('BEGINPATH' == g) Je.G.newPath(l);
      else if ('ENDPATH' == g);
      else if ('CLOSEFIGURE' == g) Je.G.closePath(l);
      else if ('MOVETOEX' == g) Je.G.moveTo(l, c(e, m), c(e, m + 4));
      else if ('LINETO' == g) {
        if (0 == l.pth.cmds.length) {
          var F = l.ctm.slice(0);
          Je.M.invert(F);
          var B = Je.M.multPoint(F, l.cpos);
          Je.G.moveTo(l, B[0], B[1]);
        }
        Je.G.lineTo(l, c(e, m), c(e, m + 4));
      } else if (
        'POLYGON' == g ||
        'POLYGON16' == g ||
        'POLYLINE' == g ||
        'POLYLINE16' == g ||
        'POLYLINETO' == g ||
        'POLYLINETO16' == g
      ) {
        m += 16;
        var P = g.startsWith('POLYGON'),
          k = -1 != g.indexOf('TO'),
          _ = u(e, m);
        (m += 4),
          k || Je.G.newPath(l),
          (m = Ke._drawPoly(e, m, _, l, g.endsWith('16') ? 2 : 4, P, k)),
          k || Ke._draw(t, l, r, P);
      } else if ('POLYPOLYGON16' == g) {
        m += 16;
        (P = g.startsWith('POLYPOLYGON')), (k = -1 != g.indexOf('TO'));
        var D = u(e, m);
        m += 4;
        var X = (m += 4);
        (m += 4 * D), k || Je.G.newPath(l);
        for (O = 0; O < D; O++) {
          var G = o(e, X + 4 * O);
          m = Ke._drawPoly(e, m, G, l, g.endsWith('16') ? 2 : 4, P, k);
        }
        k || Ke._draw(t, l, r, P);
      } else if (
        'POLYBEZIER' == g ||
        'POLYBEZIER16' == g ||
        'POLYBEZIERTO' == g ||
        'POLYBEZIERTO16' == g
      ) {
        m += 16;
        var V = g.endsWith('16'),
          W = V ? s : c,
          H = V ? 2 : 4;
        _ = u(e, m);
        for (
          m += 4,
            -1 == g.indexOf('TO') && (Je.G.moveTo(l, W(e, m), W(e, m + H)), (m += 2 * H), _--);
          _ > 0;

        )
          Je.G.curveTo(
            l,
            W(e, m),
            W(e, m + H),
            W(e, m + 2 * H),
            W(e, m + 3 * H),
            W(e, m + 4 * H),
            W(e, m + 5 * H),
          ),
            (m += 6 * H),
            (_ -= 3);
      } else if ('RECTANGLE' == g || 'ELLIPSE' == g) {
        Je.G.newPath(l);
        var z = Ke._readBox(e, m);
        if ('RECTANGLE' == g)
          Je.G.moveTo(l, z[0], z[1]),
            Je.G.lineTo(l, z[2], z[1]),
            Je.G.lineTo(l, z[2], z[3]),
            Je.G.lineTo(l, z[0], z[3]);
        else {
          var q = (z[0] + z[2]) / 2,
            U = (z[1] + z[3]) / 2;
          Je.G.arc(l, q, U, (z[2] - z[0]) / 2, 0, 2 * Math.PI, !1);
        }
        Je.G.closePath(l), Ke._draw(t, l, r, !0);
      } else if ('FILLPATH' == g) t.Fill(l, !1);
      else if ('STROKEPATH' == g) t.Stroke(l);
      else if ('STROKEANDFILLPATH' == g) t.Fill(l, !1), t.Stroke(l);
      else if ('SETWORLDTRANSFORM' == g || 'MODIFYWORLDTRANSFORM' == g) {
        var j = [];
        for (O = 0; O < 6; O++) j.push(h(e, m + 4 * O));
        if (((m += 24), 'SETWORLDTRANSFORM' == g)) l.ctm = j;
        else {
          I = u(e, m);
          if (((m += 4), 2 != I)) throw 'e';
          var Y = l.ctm;
          (l.ctm = j), Je.M.concat(l.ctm, Y);
        }
      } else if ('SETSTRETCHBLTMODE' == g) u(e, m), (m += 4);
      else if ('STRETCHDIBITS' == g) {
        z = Ke._readBox(e, m);
        var $ = c(e, (m += 16)),
          Z = c(e, (m += 4));
        c(e, (m += 4)), c(e, (m += 4));
        var J = c(e, (m += 4)),
          K = c(e, (m += 4)),
          Q = u(e, (m += 4)) + n - 8;
        u(e, (m += 4));
        var ee = u(e, (m += 4)) + n - 8;
        if ((u(e, (m += 4)), 0 != u(e, (m += 4)))) throw 'e';
        u(e, (m += 4));
        var te = c(e, (m += 4)),
          le = c(e, (m += 4));
        (m += 4), u(e, Q);
        var ne = u(e, (Q += 4)),
          re = u(e, (Q += 4));
        if (ne != J || re != K) throw 'e';
        var ie = o(e, (Q += 4)),
          ae = o(e, (Q += 2));
        if (8 != ae && 24 != ae && 32 != ae) throw ae + ' e';
        var se = u(e, (Q += 2));
        if (0 != se) throw se + ' e';
        u(e, (Q += 4)), u(e, (Q += 4)), u(e, (Q += 4)), u(e, (Q += 4)), u(e, (Q += 4)), (Q += 4);
        var oe = Math.floor(((ne * ie * ae + 31) & -32) / 8),
          ce = new Uint8Array(ne * re * 4);
        if (8 == ae)
          for (U = 0; U < re; U++)
            for (q = 0; q < ne; q++) {
              var ue = (U * ne + q) << 2;
              y = e[ee + (re - 1 - U) * oe + q] << 2;
              (ce[ue] = e[Q + y + 2]),
                (ce[ue + 1] = e[Q + y + 1]),
                (ce[ue + 2] = e[Q + y + 0]),
                (ce[ue + 3] = 255);
            }
        if (24 == ae)
          for (U = 0; U < re; U++)
            for (q = 0; q < ne; q++) {
              var he = ee + (re - 1 - U) * oe + 3 * q;
              (ce[(ue = (U * ne + q) << 2)] = e[he + 2]),
                (ce[ue + 1] = e[he + 1]),
                (ce[ue + 2] = e[he + 0]),
                (ce[ue + 3] = 255);
            }
        if (32 == ae)
          for (U = 0; U < re; U++)
            for (q = 0; q < ne; q++) {
              he = ee + (re - 1 - U) * oe + 4 * q;
              (ce[(ue = (U * ne + q) << 2)] = e[he + 2]),
                (ce[ue + 1] = e[he + 1]),
                (ce[ue + 2] = e[he + 0]),
                (ce[ue + 3] = e[he + 3]);
            }
        var fe = l.ctm.slice(0);
        (l.ctm = [1, 0, 0, 1, 0, 0]),
          Je.M.scale(l.ctm, te, -le),
          Je.M.translate(l.ctm, $, Z + le),
          Je.M.concat(l.ctm, fe),
          t.PutImage(l, ce, ne, re),
          (l.ctm = fe);
      } else console.log(g, d);
      null != p && (i[E] = p), (n += d - 8);
    }
    t.ShowPage(), t.Done();
  }),
    (Ke._readBox = function (e, t) {
      for (var l = [], n = 0; n < 4; n++) l[n] = Ke.B.readInt(e, t + 4 * n);
      return l;
    }),
    (Ke._updateCtm = function (e, t) {
      var l = [1, 0, 0, 1, 0, 0],
        n = e.wbb;
      e.bb;
      var r = e.vbb && 4 == e.vbb.length ? e.vbb : e.bb;
      Je.M.translate(l, -n[0], -n[1]),
        Je.M.scale(l, 1 / n[2], 1 / n[3]),
        Je.M.scale(l, r[2], r[3]),
        (t.ctm = l);
    }),
    (Ke._draw = function (e, t, l, n) {
      l.fill && n && e.Fill(t, !1), l.strk && 0 != t.lwidth && e.Stroke(t);
    }),
    (Ke._drawPoly = function (e, t, l, n, r, i, a) {
      for (var s = 2 == r ? Ke.B.readShort : Ke.B.readInt, o = 0; o < l; o++) {
        var c = s(e, t),
          u = s(e, (t += r));
        (t += r), 0 != o || a ? Je.G.lineTo(n, c, u) : Je.G.moveTo(n, c, u);
      }
      return i && Je.G.closePath(n), t;
    }),
    ((Ke.B = {
      uint8: new Uint8Array(4),
      readShort: function (e, t) {
        var l = Ke.B.uint8;
        return (l[0] = e[t]), (l[1] = e[t + 1]), Ke.B.int16[0];
      },
      readUshort: function (e, t) {
        var l = Ke.B.uint8;
        return (l[0] = e[t]), (l[1] = e[t + 1]), Ke.B.uint16[0];
      },
      readInt: function (e, t) {
        var l = Ke.B.uint8;
        return (
          (l[0] = e[t]), (l[1] = e[t + 1]), (l[2] = e[t + 2]), (l[3] = e[t + 3]), Ke.B.int32[0]
        );
      },
      readUint: function (e, t) {
        var l = Ke.B.uint8;
        return (
          (l[0] = e[t]), (l[1] = e[t + 1]), (l[2] = e[t + 2]), (l[3] = e[t + 3]), Ke.B.uint32[0]
        );
      },
      readFloat: function (e, t) {
        var l = Ke.B.uint8;
        return (
          (l[0] = e[t]), (l[1] = e[t + 1]), (l[2] = e[t + 2]), (l[3] = e[t + 3]), Ke.B.flot32[0]
        );
      },
      readASCII: function (e, t, l) {
        for (var n = '', r = 0; r < l; r++) n += String.fromCharCode(e[t + r]);
        return n;
      },
    }).int16 = new Int16Array(Ke.B.uint8.buffer)),
    (Ke.B.uint16 = new Uint16Array(Ke.B.uint8.buffer)),
    (Ke.B.int32 = new Int32Array(Ke.B.uint8.buffer)),
    (Ke.B.uint32 = new Uint32Array(Ke.B.uint8.buffer)),
    (Ke.B.flot32 = new Float32Array(Ke.B.uint8.buffer)),
    (Ke.C = {
      EMR_HEADER: 1,
      EMR_POLYBEZIER: 2,
      EMR_POLYGON: 3,
      EMR_POLYLINE: 4,
      EMR_POLYBEZIERTO: 5,
      EMR_POLYLINETO: 6,
      EMR_POLYPOLYLINE: 7,
      EMR_POLYPOLYGON: 8,
      EMR_SETWINDOWEXTEX: 9,
      EMR_SETWINDOWORGEX: 10,
      EMR_SETVIEWPORTEXTEX: 11,
      EMR_SETVIEWPORTORGEX: 12,
      EMR_SETBRUSHORGEX: 13,
      EMR_EOF: 14,
      EMR_SETPIXELV: 15,
      EMR_SETMAPPERFLAGS: 16,
      EMR_SETMAPMODE: 17,
      EMR_SETBKMODE: 18,
      EMR_SETPOLYFILLMODE: 19,
      EMR_SETROP2: 20,
      EMR_SETSTRETCHBLTMODE: 21,
      EMR_SETTEXTALIGN: 22,
      EMR_SETCOLORADJUSTMENT: 23,
      EMR_SETTEXTCOLOR: 24,
      EMR_SETBKCOLOR: 25,
      EMR_OFFSETCLIPRGN: 26,
      EMR_MOVETOEX: 27,
      EMR_SETMETARGN: 28,
      EMR_EXCLUDECLIPRECT: 29,
      EMR_INTERSECTCLIPRECT: 30,
      EMR_SCALEVIEWPORTEXTEX: 31,
      EMR_SCALEWINDOWEXTEX: 32,
      EMR_SAVEDC: 33,
      EMR_RESTOREDC: 34,
      EMR_SETWORLDTRANSFORM: 35,
      EMR_MODIFYWORLDTRANSFORM: 36,
      EMR_SELECTOBJECT: 37,
      EMR_CREATEPEN: 38,
      EMR_CREATEBRUSHINDIRECT: 39,
      EMR_DELETEOBJECT: 40,
      EMR_ANGLEARC: 41,
      EMR_ELLIPSE: 42,
      EMR_RECTANGLE: 43,
      EMR_ROUNDRECT: 44,
      EMR_ARC: 45,
      EMR_CHORD: 46,
      EMR_PIE: 47,
      EMR_SELECTPALETTE: 48,
      EMR_CREATEPALETTE: 49,
      EMR_SETPALETTEENTRIES: 50,
      EMR_RESIZEPALETTE: 51,
      EMR_REALIZEPALETTE: 52,
      EMR_EXTFLOODFILL: 53,
      EMR_LINETO: 54,
      EMR_ARCTO: 55,
      EMR_POLYDRAW: 56,
      EMR_SETARCDIRECTION: 57,
      EMR_SETMITERLIMIT: 58,
      EMR_BEGINPATH: 59,
      EMR_ENDPATH: 60,
      EMR_CLOSEFIGURE: 61,
      EMR_FILLPATH: 62,
      EMR_STROKEANDFILLPATH: 63,
      EMR_STROKEPATH: 64,
      EMR_FLATTENPATH: 65,
      EMR_WIDENPATH: 66,
      EMR_SELECTCLIPPATH: 67,
      EMR_ABORTPATH: 68,
      EMR_COMMENT: 70,
      EMR_FILLRGN: 71,
      EMR_FRAMERGN: 72,
      EMR_INVERTRGN: 73,
      EMR_PAINTRGN: 74,
      EMR_EXTSELECTCLIPRGN: 75,
      EMR_BITBLT: 76,
      EMR_STRETCHBLT: 77,
      EMR_MASKBLT: 78,
      EMR_PLGBLT: 79,
      EMR_SETDIBITSTODEVICE: 80,
      EMR_STRETCHDIBITS: 81,
      EMR_EXTCREATEFONTINDIRECTW: 82,
      EMR_EXTTEXTOUTA: 83,
      EMR_EXTTEXTOUTW: 84,
      EMR_POLYBEZIER16: 85,
      EMR_POLYGON16: 86,
      EMR_POLYLINE16: 87,
      EMR_POLYBEZIERTO16: 88,
      EMR_POLYLINETO16: 89,
      EMR_POLYPOLYLINE16: 90,
      EMR_POLYPOLYGON16: 91,
      EMR_POLYDRAW16: 92,
      EMR_CREATEMONOBRUSH: 93,
      EMR_CREATEDIBPATTERNBRUSHPT: 94,
      EMR_EXTCREATEPEN: 95,
      EMR_POLYTEXTOUTA: 96,
      EMR_POLYTEXTOUTW: 97,
      EMR_SETICMMODE: 98,
      EMR_CREATECOLORSPACE: 99,
      EMR_SETCOLORSPACE: 100,
      EMR_DELETECOLORSPACE: 101,
      EMR_GLSRECORD: 102,
      EMR_GLSBOUNDEDRECORD: 103,
      EMR_PIXELFORMAT: 104,
      EMR_DRAWESCAPE: 105,
      EMR_EXTESCAPE: 106,
      EMR_SMALLTEXTOUT: 108,
      EMR_FORCEUFIMAPPING: 109,
      EMR_NAMEDESCAPE: 110,
      EMR_COLORCORRECTPALETTE: 111,
      EMR_SETICMPROFILEA: 112,
      EMR_SETICMPROFILEW: 113,
      EMR_ALPHABLEND: 114,
      EMR_SETLAYOUT: 115,
      EMR_TRANSPARENTBLT: 116,
      EMR_GRADIENTFILL: 118,
      EMR_SETLINKEDUFIS: 119,
      EMR_SETTEXTJUSTIFICATION: 120,
      EMR_COLORMATCHTOTARGETW: 121,
      EMR_CREATECOLORSPACEW: 122,
    }),
    (Ke.K = []);
  let Qe = function (e, t) {
    (this.canvas = document.createElement('canvas')),
      (this.ctx = this.canvas.getContext('2d')),
      (this.bb = null),
      (this.currPage = 0),
      (this.needPage = e),
      (this.scale = t);
  };
  (Qe.prototype.StartPage = function (e, t, l, n) {
    if (this.currPage == this.needPage) {
      this.bb = [e, t, l, n];
      var r = this.scale,
        i = window.devicePixelRatio,
        a = this.canvas,
        s = this.ctx;
      (a.width = Math.round(l * r)),
        (a.height = Math.round(n * r)),
        s.translate(0, n * r),
        s.scale(r, -r),
        a.setAttribute(
          'style',
          'border:1px solid; width:' + a.width / i + 'px; height:' + a.height / i + 'px',
        );
    }
  }),
    (Qe.prototype.Fill = function (e, t) {
      if (this.currPage == this.needPage) {
        var l = this.ctx;
        l.beginPath(), this._setStyle(e, l), this._draw(e.pth, l), l.fill();
      }
    }),
    (Qe.prototype.Stroke = function (e) {
      if (this.currPage == this.needPage) {
        var t = this.ctx;
        t.beginPath(), this._setStyle(e, t), this._draw(e.pth, t), t.stroke();
      }
    }),
    (Qe.prototype.PutText = function (e, t, l) {
      if (this.currPage == this.needPage) {
        this._scale(e.ctm);
        var n = this.ctx;
        this._setStyle(e, n), n.save();
        var r = [1, 0, 0, -1, 0, 0];
        this._concat(r, e.font.Tm),
          this._concat(r, e.ctm),
          n.transform(r[0], r[1], r[2], r[3], r[4], r[5]),
          n.fillText(t, 0, 0),
          n.restore();
      }
    }),
    (Qe.prototype.PutImage = function (e, t, l, n, r) {
      if (this.currPage == this.needPage) {
        var i = this.ctx;
        if (t.length == l * n * 4) {
          if (((t = t.slice(0)), r && r.length == l * n * 4))
            for (var a = 0; a < t.length; a += 4) t[a + 3] = r[a + 1];
          var s = document.createElement('canvas'),
            o = s.getContext('2d');
          (s.width = l), (s.height = n);
          var c = o.createImageData(l, n);
          for (a = 0; a < t.length; a++) c.data[a] = t[a];
          o.putImageData(c, 0, 0), i.save();
          var u = [1, 0, 0, 1, 0, 0];
          this._concat(u, [1 / l, 0, 0, -1 / n, 0, 1]),
            this._concat(u, e.ctm),
            i.transform(u[0], u[1], u[2], u[3], u[4], u[5]),
            i.drawImage(s, 0, 0),
            i.restore();
        }
      }
    }),
    (Qe.prototype.ShowPage = function () {
      this.currPage++;
    }),
    (Qe.prototype.Done = function () {}),
    (Qe.prototype._setStyle = function (e, t) {
      var l = this._scale(e.ctm);
      (t.fillStyle = this._getFill(e.colr, e.ca, t)),
        (t.strokeStyle = this._getFill(e.COLR, e.CA, t)),
        (t.lineCap = ['butt', 'round', 'square'][e.lcap]),
        (t.lineJoin = ['miter', 'round', 'bevel'][e.ljoin]),
        (t.lineWidth = e.lwidth * l);
      for (var n, r = e.dash.slice(0), i = 0; i < r.length; i++)
        r[i] = ((n = r[i] * l), '' + parseFloat(n.toFixed(2)));
      t.setLineDash(r), (t.miterLimit = e.mlimit * l);
      var a = e.font.Tf,
        s = a.toLowerCase(),
        o = -1 != s.indexOf('bold') ? 'bold ' : '',
        c = -1 != s.indexOf('italic') || -1 != s.indexOf('oblique') ? 'italic ' : '';
      t.font = o + c + e.font.Tfs + 'px "' + a + '"';
    }),
    (Qe.prototype._getFill = function (e, t, l) {
      if (null == e.typ) return this._colr(e, t);
      var n,
        r = e,
        i = r.crds,
        a = r.mat,
        s = this._scale(a);
      if ('lin' == r.typ) {
        var o = this._multPoint(a, i.slice(0, 2)),
          c = this._multPoint(a, i.slice(2));
        n = l.createLinearGradient(o[0], o[1], c[0], c[1]);
      } else if ('rad' == r.typ) {
        (o = this._multPoint(a, i.slice(0, 2))), (c = this._multPoint(a, i.slice(3)));
        n = l.createRadialGradient(o[0], o[1], i[2] * s, c[0], c[1], i[5] * s);
      }
      for (var u = 0; u < r.grad.length; u++)
        n.addColorStop(r.grad[u][0], this._colr(r.grad[u][1], t));
      return n;
    }),
    (Qe.prototype._colr = function (e, t) {
      return (
        'rgba(' +
        Math.round(255 * e[0]) +
        ',' +
        Math.round(255 * e[1]) +
        ',' +
        Math.round(255 * e[2]) +
        ',' +
        t +
        ')'
      );
    }),
    (Qe.prototype._scale = function (e) {
      return Math.sqrt(Math.abs(e[0] * e[3] - e[1] * e[2]));
    }),
    (Qe.prototype._concat = function (e, t) {
      var l = e[0],
        n = e[1],
        r = e[2],
        i = e[3],
        a = e[4],
        s = e[5];
      (e[0] = l * t[0] + n * t[2]),
        (e[1] = l * t[1] + n * t[3]),
        (e[2] = r * t[0] + i * t[2]),
        (e[3] = r * t[1] + i * t[3]),
        (e[4] = a * t[0] + s * t[2] + t[4]),
        (e[5] = a * t[1] + s * t[3] + t[5]);
    }),
    (Qe.prototype._multPoint = function (e, t) {
      var l = t[0],
        n = t[1];
      return [l * e[0] + n * e[2] + e[4], l * e[1] + n * e[3] + e[5]];
    }),
    (Qe.prototype._draw = function (e, t) {
      for (var l = 0, n = e.crds, r = 0; r < e.cmds.length; r++) {
        var i = e.cmds[r];
        'M' == i
          ? (t.moveTo(n[l], n[l + 1]), (l += 2))
          : 'L' == i
          ? (t.lineTo(n[l], n[l + 1]), (l += 2))
          : 'C' == i
          ? (t.bezierCurveTo(n[l], n[l + 1], n[l + 2], n[l + 3], n[l + 4], n[l + 5]), (l += 6))
          : 'Q' == i
          ? (t.quadraticCurveTo(n[l], n[l + 1], n[l + 2], n[l + 3]), (l += 4))
          : 'Z' == i && t.closePath();
      }
    });
  class et {
    constructor(e) {
      if (null != e) {
        this.images = {};
        for (let i in e)
          if (i.indexOf('xl/media/') > -1) {
            let a = i.split('.'),
              s = a[a.length - 1].toLowerCase();
            if (s in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1, emf: 1 })
              if ('emf' == s) {
                var t,
                  l,
                  n = new Qe(0, 1);
                for (var r in ((l = Ke.K = []), (t = Ke.C))) l[t[r]] = r.slice(4);
                Ke.Parse(e[i], n), (this.images[i] = n.canvas.toDataURL('image/png'));
              } else this.images[i] = e[i];
          }
      }
    }
    getImageByName(e) {
      if (e in this.images) {
        let t = this.images[e];
        return new tt(e, t);
      }
      return null;
    }
  }
  class tt extends Se {
    constructor(e, t) {
      super(), (this.src = t);
    }
    setDefault() {}
  }
  class lt {
    constructor(e) {
      let t = e.getElementsByTagName('definedNames/definedName', m);
      const l = {};
      t.forEach((e) => {
        const t = new nt(e);
        l[t.id] = t;
      }),
        (this.defineNames = l);
    }
  }
  class nt {
    constructor(e) {
      (this.id = ne(6)),
        (this.name = e.get('name')),
        (this.formulaOrRefString = W(e.value)),
        (this.comment = e.get('comment')),
        (this.localSheetId = e.get('localSheetId')),
        (this.hidden = '1' === e.get('hidden'));
    }
  }
  class rt extends ge {
    constructor(e, t) {
      super(),
        (this.columnWidthSet = []),
        (this.rowHeightSet = []),
        (this.handleWorkBookInfo = () => {
          this.workbook = new de();
          const e = new lt(this.readXml);
          e?.defineNames && (this.workbook.defineNames = e.defineNames);
        }),
        (this.files = e),
        (this.fileName = t),
        (this.readXml = new ce(e)),
        this.getSheetNameList(),
        (this.sharedStrings = this.readXml.getElementsByTagName('sst/si', 'xl/sharedStrings.xml')),
        (this.calcChain = this.readXml.getElementsByTagName('calcChain/c', 'xl/calcChain.xml')),
        (this.styles = {}),
        (this.styles.cellXfs = this.readXml.getElementsByTagName('cellXfs/xf', p)),
        (this.styles.cellStyleXfs = this.readXml.getElementsByTagName('cellStyleXfs/xf', p)),
        (this.styles.cellStyles = this.readXml.getElementsByTagName('cellStyles/cellStyle', p)),
        (this.styles.fonts = this.readXml.getElementsByTagName('fonts/font', p)),
        (this.styles.fills = this.readXml.getElementsByTagName('fills/fill', p)),
        (this.styles.borders = this.readXml.getElementsByTagName('borders/border', p)),
        (this.styles.clrScheme = this.readXml.getElementsByTagName(
          'a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink',
          'xl/theme/theme1.xml',
        )),
        (this.styles.indexedColors = this.readXml.getElementsByTagName(
          'colors/indexedColors/rgbColor',
          p,
        )),
        (this.styles.mruColors = this.readXml.getElementsByTagName('colors/mruColors/color', p)),
        (this.styles.dxfs = this.readXml.getElementsByTagName('dxfs/dxf', p)),
        (this.imageList = new et(e)),
        (this.cellImages = this.readXml.getElementsByTagName(
          'etc:cellImages/etc:cellImage',
          'xl/cellimages.xml',
        ));
      let l = this.readXml.getElementsByTagName('numFmt/numFmt', p),
        n = JSON.parse(JSON.stringify(y));
      for (let e = 0; e < l.length; e++) {
        let t = l[e].attributeList,
          r = k(t, 'numFmtId', '49'),
          i = k(t, 'formatCode', '@');
        r in y || (n[r] = I[i] || i);
      }
      this.styles.numfmts = n;
    }
    getSheetNameList() {
      let e = this.readXml.getElementsByTagName(
        'Relationships/Relationship',
        'xl/_rels/workbook.xml.rels',
      );
      if (null == e) return;
      let t = new RegExp('worksheets/[^/]*?.xml'),
        l = {};
      for (let n = 0; n < e.length; n++) {
        let r = e[n].attributeList,
          i = r.Id,
          a = r.Target;
        t.test(a) && (0 === a.indexOf('/xl') ? (l[i] = a.substr(1)) : (l[i] = 'xl/' + a));
      }
      this.sheetNameList = l;
    }
    getSheetFileBysheetId(e) {
      return this.sheetNameList[e];
    }
    getWorkBookInfo() {
      let e = this.readXml.getElementsByTagName('Company', d),
        t = this.readXml.getElementsByTagName('AppVersion', d),
        l = this.readXml.getElementsByTagName('dc:creator', g),
        n = this.readXml.getElementsByTagName('cp:lastModifiedBy', g),
        r = this.readXml.getElementsByTagName('dcterms:created', g),
        i = this.readXml.getElementsByTagName('dcterms:modified', g);
      (this.info = new pe()),
        (this.info.name = this.fileName),
        (this.info.creator = l.length > 0 ? l[0].value : ''),
        (this.info.lastmodifiedby = n.length > 0 ? n[0].value : ''),
        (this.info.createdTime = r.length > 0 ? r[0].value : ''),
        (this.info.modifiedTime = i.length > 0 ? i[0].value : ''),
        (this.info.company = e.length > 0 ? e[0].value : ''),
        (this.info.appversion = t.length > 0 ? t[0].value : '');
    }
    getSheetsFull(e = !0) {
      let t = this.readXml.getElementsByTagName('sheets/sheet', m),
        l = {};
      for (let e in t) {
        let n = t[e];
        l[n.attributeList.name] = n.attributeList.sheetId;
      }
      this.sheets = [];
      let n = 0;
      for (let r in t) {
        let i,
          a,
          s = t[r],
          o = s.attributeList.name,
          c = s.attributeList.sheetId,
          u = s.attributeList['r:id'],
          h = this.getSheetFileBysheetId(u),
          f = 'hidden' === s.attributeList.state ? 1 : 0,
          g = this.readXml.getElementsByTagName('worksheet/drawing', h);
        if (null != g && g.length > 0) {
          let e = k(g[0].attributeList, 'r:id', null);
          null != e && ((i = this.getDrawingFile(e, h)), (a = this.getDrawingRelsFile(i)));
        }
        if (null != h) {
          let t = new Ze(o, c, n, e, {
            sheetFile: h,
            readXml: this.readXml,
            sheetList: l,
            styles: this.styles,
            sharedStrings: this.sharedStrings,
            calcChain: this.calcChain,
            imageList: this.imageList,
            drawingFile: i,
            drawingRelsFile: a,
            hide: f,
            cellImages: this.cellImages,
          });
          (this.columnWidthSet = []),
            (this.rowHeightSet = []),
            this.imagePositionCaculation(t),
            this.sheets.push(t),
            n++;
        }
      }
    }
    extendArray(e, t, l, n, r) {
      if (e < t.length) return;
      let i = t.length,
        a = e,
        s = 0;
      i > 0 && (s = t[i - 1]);
      for (let e = i; e <= a; e++) {
        let i = l,
          a = e.toString();
        a in n ? (i = 0) : a in r && (i = r[a]), (s += Math.round(i + 1)), t.push(s);
      }
    }
    imagePositionCaculation(e) {
      let t = e.images,
        l = e.defaultColWidth,
        n = e.defaultRowHeight,
        r = {};
      e.config.colhidden && (r = e.config.colhidden);
      let i = {};
      e.config.columnlen && (i = e.config.columnlen);
      let a = {};
      e.config.rowhidden && (a = e.config.rowhidden);
      let s = {};
      e.config.rowlen && (s = e.config.rowlen);
      for (let e in t) {
        let o = t[e],
          c = o.fromCol,
          u = o.fromColOff,
          h = o.fromRow,
          f = o.fromRowOff,
          g = o.toCol,
          d = o.toColOff,
          m = o.toRow,
          p = o.toRowOff,
          E = 0,
          b = 0,
          T = 0,
          y = 0;
        c >= this.columnWidthSet.length && this.extendArray(c, this.columnWidthSet, l, r, i),
          (E = 0 == c ? 0 : this.columnWidthSet[c - 1]),
          (E += u),
          h >= this.rowHeightSet.length && this.extendArray(h, this.rowHeightSet, n, a, s),
          (b = 0 == h ? 0 : this.rowHeightSet[h - 1]),
          (b += f),
          g >= this.columnWidthSet.length && this.extendArray(g, this.columnWidthSet, l, r, i),
          (T = 0 == g ? 0 : this.columnWidthSet[g - 1]),
          (T = T + d - E),
          m >= this.rowHeightSet.length && this.extendArray(m, this.rowHeightSet, n, a, s),
          (y = 0 == m ? 0 : this.rowHeightSet[m - 1]),
          (y = y + p - b),
          (o.originWidth = T),
          (o.originHeight = y),
          (o.crop.height = y),
          (o.crop.width = T),
          (o.default.height = y),
          (o.default.left = E),
          (o.default.top = b),
          (o.default.width = T);
      }
    }
    getDrawingFile(e, t) {
      let l = t.split('/'),
        n = 'xl/worksheets/_rels/' + l[l.length - 1] + '.rels',
        r = this.readXml.getElementsByTagName('Relationships/Relationship', n);
      if (r.length > 0)
        for (let t = 0; t < r.length; t++) {
          let l = r[t].attributeList;
          if (k(l, 'Id', null) == e) {
            let e = k(l, 'Target', null);
            if (null != e) return e.replace(/\.\.\//g, '');
          }
        }
      return null;
    }
    getDrawingRelsFile(e) {
      let t = e.split('/');
      return 'xl/drawings/_rels/' + t[t.length - 1] + '.rels';
    }
    getSheetsWithoutCell() {
      this.getSheetsFull(!1);
    }
    Parse() {
      return (
        this.getWorkBookInfo(),
        this.handleWorkBookInfo(),
        this.getSheetsFull(),
        this.toJsonString(this)
      );
    }
    toJsonString(e) {
      let t = new ge();
      return (
        (t.info = e.info),
        (t.workbook = e.workbook),
        (t.sheets = []),
        e.sheets.forEach((e) => {
          let l = new me();
          null != e.name && (l.name = e.name),
            null != e.color && (l.color = e.color),
            null != e.config && (l.config = e.config),
            null != e.index && (l.index = e.index),
            null != e.status && (l.status = e.status),
            null != e.order && (l.order = e.order),
            null != e.row && (l.row = e.row),
            null != e.column && (l.column = e.column),
            null != e.luckysheet_select_save &&
              (l.luckysheet_select_save = e.luckysheet_select_save),
            null != e.scrollLeft && (l.scrollLeft = e.scrollLeft),
            null != e.scrollTop && (l.scrollTop = e.scrollTop),
            null != e.zoomRatio && (l.zoomRatio = e.zoomRatio),
            null != e.showGridLines && (l.showGridLines = e.showGridLines),
            null != e.defaultColWidth && (l.defaultColWidth = e.defaultColWidth),
            null != e.defaultRowHeight && (l.defaultRowHeight = e.defaultRowHeight),
            null != e.celldata &&
              ((l.celldata = []),
              e.celldata.forEach((e) => {
                let t = new Ee();
                (t.r = e.r), (t.c = e.c), (t.v = e.v), l.celldata.push(t);
              })),
            null != e.chart && (l.chart = e.chart),
            null != e.isPivotTable && (l.isPivotTable = e.isPivotTable),
            null != e.pivotTable && (l.pivotTable = e.pivotTable),
            null != e.luckysheet_conditionformat_save &&
              (l.luckysheet_conditionformat_save = e.luckysheet_conditionformat_save),
            null != e.freezen && (l.freezen = e.freezen),
            null != e.calcChain && (l.calcChain = e.calcChain),
            null != e.images && (l.images = e.images),
            null != e.charts && (l.charts = e.charts),
            null != e.dataVerification && (l.dataVerification = e.dataVerification),
            null != e.hyperlink && (l.hyperlink = e.hyperlink),
            null != e.hide && (l.hide = e.hide),
            null != e.conditionalFormatting &&
              e.conditionalFormatting.length &&
              (l.conditionalFormatting = e.conditionalFormatting),
            null != e.dataVerificationList &&
              e.dataVerificationList.length &&
              (l.dataVerificationList = e.dataVerificationList),
            null != e.filter && (l.filter = e.filter),
            t.sheets.push(l);
        }),
        JSON.stringify(t)
      );
    }
  }
  class it {
    constructor(e) {
      this.uploadFile = e;
    }
    unzipFile(e, t) {
      new o.default().loadAsync(this.uploadFile).then(
        function (t) {
          let l = {},
            n = Object.keys(t.files).length,
            r = 0;
          t.forEach(function (t, i) {
            let a = i.name.split('.'),
              s = a[a.length - 1].toLowerCase(),
              o = 'string';
            s in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1 }
              ? (o = 'base64')
              : 'emf' == s && (o = 'arraybuffer'),
              i.async(o).then(function (t) {
                'base64' == o && (t = 'data:image/' + s + ';base64,' + t),
                  (l[i.name] = t),
                  n == r + 1 && e(l),
                  r++;
              });
          });
        },
        function (e) {
          t(e);
        },
      );
    }
    unzipFileByUrl(e, t, l) {
      var n = new o.default();
      q(e, function (e, r) {
        if (e) throw e;
        n.loadAsync(r).then(
          function (e) {
            let l = {},
              n = Object.keys(e.files).length,
              r = 0;
            e.forEach(function (e, i) {
              let a = i.name.split('.'),
                s = a[a.length - 1].toLowerCase(),
                o = 'string';
              s in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1 }
                ? (o = 'base64')
                : 'emf' == s && (o = 'arraybuffer'),
                i.async(o).then(function (e) {
                  'base64' == o && (e = 'data:image/' + s + ';base64,' + e),
                    (l[i.name] = e),
                    n == r + 1 && t(l),
                    r++;
                });
            });
          },
          function (e) {
            l(e);
          },
        );
      });
    }
    newZipFile() {
      var e = new o.default();
      this.workBook = e;
    }
    addToZipFile(e, t) {
      if (null == this.workBook) {
        var l = new o.default();
        this.workBook = l;
      }
      this.workBook.file(e, t);
    }
  }
  function at(e, t = '') {
    if (!e) return e;
    const l = st[e];
    return l && (e = l), e.toLocaleUpperCase().replace('#', t);
  }
  const st = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    'indianred ': '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370d8',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#d87093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
  };
  function ot(e) {
    return (e / 96) * 72;
  }
  function ct(e) {
    return (e - 10) / 8 + 0.83 + 0.64;
  }
  function ut(e, t) {
    if (void 0 !== e) return void 0 === t ? e : t;
  }
  function ht(e = {}, t, l = !1) {
    return {
      numFmt: t,
      font: ft(e),
      alignment: dt(e),
      protection: null,
      border: gt(e.bd),
      fill: mt(e.bg?.rgb, l),
    };
  }
  function ft(e) {
    const t = {
      underline: { 10: 'double', 12: 'single' },
      vertAlign: { 1: void 0, 2: 'subscript', 3: 'superscript' },
    };
    return {
      name: e.ff,
      size: e.fs,
      family: 1,
      color: ut(e.cl?.rgb, { argb: at(e.cl?.rgb) }),
      bold: ut(e.bl, 1 === e.bl),
      italic: ut(e.it, 1 === e.it),
      underline: ut(e.ul?.s, 1 === e.ul?.s && (t.underline[e.ul.t] || !0)),
      vertAlign: ut(e.va, t.vertAlign[e.va]),
      strike: ut(e.st?.s, 1 === e.st?.s),
      outline: ut(e.ol?.s, 1 === e.ol?.s),
      charset: 134,
    };
  }
  function gt(e) {
    if (!e) return null;
    const t = {
        0: 'none',
        1: 'thin',
        2: 'hair',
        3: 'dotted',
        4: 'dashDot',
        5: 'dashDot',
        6: 'dashDotDot',
        7: 'double',
        8: 'medium',
        9: 'mediumDashed',
        10: 'mediumDashDot',
        11: 'mediumDashDotDot',
        12: 'slantDashDot',
        13: 'thick',
      },
      l = (e) => {
        if (!e) return;
        return { style: t[e?.s || 1], color: { argb: at(e?.cl?.rgb || '#d9d9d9') } };
      },
      n = l(e.bl_tr || e.tl_br) || {};
    return {
      top: l(e.t),
      right: l(e.r),
      bottom: l(e.b),
      left: l(e.l),
      diagonal: { up: !!e.bl_tr, down: !!e.tl_br, ...n },
    };
  }
  function dt(e) {
    const t = {
      horizontal: { 0: 'left', 1: 'left', 2: 'center', 3: 'right' },
      vertical: { 1: 'top', 2: 'middle', 3: 'bottom' },
      wrapText: { 3: !0 },
    };
    return {
      horizontal: ut(e.ht, t.horizontal[e.ht]),
      vertical: ut(e.vt, t.vertical[e.vt]),
      wrapText: ut(e.tb, 3 === e.tb),
      textRotation: ut(e.tr?.a),
    };
  }
  function mt(e, t = !1) {
    if (!e) return null;
    if (!e) return { type: 'pattern', pattern: 'none' };
    const l = { type: 'pattern', pattern: 'solid' };
    return t ? (l.bgColor = { argb: at(e, 'FF') }) : (l.fgColor = { argb: at(e, 'FF') }), l;
  }
  class pt {
    constructor(e, t, l, n) {
      (this.sheetId = e),
        (this.workbook = t),
        (this.worksheet = l),
        (this.resources = n),
        this.setImages(),
        this.setConditional(),
        this.setDataValidation(),
        this.setFilter();
    }
    handleRang(e) {
      const { startRow: t, startColumn: l, endRow: n, endColumn: r } = e;
      return (function (e, t) {
        let l = e.row[0],
          n = e.row[1],
          r = e.column[0],
          i = e.column[1];
        return null == l && null == n
          ? t + te(r) + ':' + te(i)
          : null == r && null == i
          ? t + (l + 1) + ':' + (n + 1)
          : r == i && l == n
          ? t + te(r) + (l + 1)
          : t + te(r) + (l + 1) + ':' + te(i) + (n + 1);
      })({ row: [t, n], column: [l, r] }, '');
    }
    setFilter() {
      const e = this.getSheetResource('SHEET_FILTER_PLUGIN');
      e && (this.worksheet.autoFilter = this.handleRang(e.ref));
    }
    setConditional() {
      const e = this.getSheetResource('SHEET_CONDITIONAL_FORMATTING_PLUGIN'),
        t = [];
      e &&
        (e.forEach((e) => {
          const { ranges: l, rule: n, stopIfTrue: r } = e;
          l.forEach((l) => {
            const n = this.handleRang(l),
              r = t.findIndex((e) => e.ref === n),
              i = this.handleRule(e);
            r > -1 ? t[r].rules.push(i) : t.push({ ref: n, rules: [i] });
          });
        }),
        t.forEach((e) => {
          this.worksheet.addConditionalFormatting(e);
        }));
    }
    setDataValidation() {
      const e = this.getSheetResource('SHEET_DATA_VALIDATION_PLUGIN'),
        t = (e, t = !1) => {
          const l = Math.round(24 * (e - 25569 + (t ? 1462 : 0)) * 3600 * 1e3);
          return new Date(l);
        };
      e?.forEach((e) => {
        const {
          ranges: l = [],
          type: n,
          allowBlank: r,
          operator: i,
          formula1: a,
          formula2: s,
          showErrorMessage: o,
          showInputMessage: c,
          prompt: u,
          promptTitle: h,
          error: f,
          errorTitle: g,
          errorStyle: d,
        } = e || {};
        let m = [a];
        se(s) || m.push(s),
          'list' === n && ((m = [`"${a}"`]), se(s) || m.push(`"${s}"`)),
          'date' === n && ((m = [t(a)]), se(s) || m.push(t(s)));
        const p = l.map((e) => this.handleRang(e)),
          E = {
            type: n,
            allowBlank: r,
            operator: i,
            formulae: m,
            showErrorMessage: o,
            showInputMessage: c,
            prompt: u,
            promptTitle: h,
            error: f,
            errorTitle: g,
            errorStyle: ['information', 'stop', 'warning'][d],
          };
        p.forEach((e) => {
          this.worksheet.dataValidations.add(e, ae(E));
        });
      });
    }
    setImages() {
      const e = this.getSheetResource('SHEET_DRAWING_PLUGIN'),
        t = e?.data;
      if (t)
        for (const e in t) {
          const l = t[e];
          let n = this.workbook
            .getImages()
            .findIndex((e) => 'png' === e.extension && e.base64 === l.source);
          -1 === n && (n = this.workbook.addImage({ base64: l.source, extension: 'png' }));
          const r = (e) => ({
            nativeCol: e.column,
            nativeColOff: P(e.columnOffset),
            nativeRow: e.row,
            nativeRowOff: P(e.rowOffset),
          });
          this.worksheet.addImage(n, { tl: r(l.sheetTransform.from), br: r(l.sheetTransform.to) });
        }
    }
    getSheetResource(e) {
      return re(this.resources.find((t) => t.name === e)?.data)[this.sheetId];
    }
    handleRule(e) {
      const { rule: t, stopIfTrue: l, order: n } = e,
        r = {};
      switch (
        (l && (r.stopIfTrue = 1),
        (r.priority = n),
        t.style && (r.style = ht(t.style, t.style.n?.pattern, !0)),
        t.operator && (r.operator = t.operator),
        t.type)
      ) {
        case Ge.colorScale:
          (r.type = Ge.colorScale),
            (r.cfvo = t.config?.map((e) => ({ type: e.value.type, value: e.value.value }))),
            (r.color = t.config?.map((e) => ({ argb: at(e.color) })));
          break;
        case Ge.dataBar:
          (r.type = Ge.dataBar),
            (r.showValue = t.isShowValue),
            (r.gradient = t.config.isGradient),
            (r.cfvo = [
              { type: t.config.min.type, value: t.config.min.value },
              { type: t.config.max.type, value: t.config.max.value },
            ]),
            (r.negativeFillColor = { argb: at(t.config.nativeColor) }),
            (r.color = { argb: at(t.config.positiveColor) }),
            (r.axisPosition = 'auto'),
            (r.direction = 'leftToRight'),
            (r.minLength = 0),
            (r.maxLength = 100),
            (r.negativeBarColorSameAsPositive = !0),
            (r.negativeBarBorderColorSameAsPositive = !0);
          break;
        case Ge.iconSet:
          (r.type = Ge.iconSet),
            (r.reverse = !1),
            (r.showValue = t.isShowValue),
            (r.icons = t.config
              ?.map((e) => ({
                iconId: le(e.iconType.charAt(0)) - le(e?.iconId) - 1,
                iconSet: e.iconType,
              }))
              .reverse()),
            (r.custom = !0),
            (r.cfvo = t.config
              ?.map((e) => ({ type: e.value.type, value: e.value.value }))
              .reverse());
          break;
        case Ge.highlightCell:
          switch (t.subType) {
            case Ve.average:
              (r.type = 'aboveAverage'), (r.aboveAverage = !1);
              break;
            case Ve.duplicateValues:
              r.type = 'duplicateValues';
              break;
            case Ve.formula:
              (r.type = 'expression'), (r.formulae = [W(t.value)]);
              break;
            case Ve.number:
              (r.type = 'cellIs'), (r.formulae = [t.value]);
              break;
            case Ve.rank:
              (r.type = 'top10'),
                (r.rank = t.value),
                (r.percent = t.isPercent),
                (r.bottom = t.isBottom);
              break;
            case Ve.text:
              (r.type = 'containsText'), (r.text = t.value);
              break;
            case Ve.timePeriod:
              (r.type = 'timePeriod'), (r.timePeriod = t.operator);
          }
      }
      return r;
    }
  }
  class Et {}
  class bt {}
  function Tt(e, t) {
    const { sheetOrder: l, sheets: n, styles: r, resources: i } = t;
    l.forEach((l) => {
      const a = n[l],
        {
          id: s,
          name: o,
          tabColor: c,
          defaultRowHeight: u,
          defaultColumnWidth: h,
          hidden: f,
          rightToLeft: g,
          showGridlines: d,
          freeze: m,
          mergeData: p,
        } = a,
        E = new Et();
      (E.rightToLeft = 1 === g), (E.showGridLines = 1 === d);
      const b = new bt();
      (m.xSplit > 0 || m.ySplit > 0) &&
        ((b.state = 'frozen'), (b.xSplit = m.xSplit), (b.ySplit = m.ySplit));
      const T = Object.assign(E, b),
        y = ct(h),
        v = ot(u),
        w = e.addWorksheet(o, {
          views: [T],
          state: 1 === f ? 'hidden' : 'visible',
          properties: {
            tabColor: c ? { argb: at(c) } : void 0,
            defaultColWidth: y,
            defaultRowHeight: v,
            dyDescent: 0,
          },
        });
      !(function (e, t = {}, l) {
        for (const n in t)
          if (Object.prototype.hasOwnProperty.call(t, n)) {
            const r = t[n],
              i = e.getColumn(Number(n) + 1);
            (i.width = r.w ? ct(r.w) : l), (i.hidden = 1 === r.hd);
          }
      })(w, a.columnData, y),
        (function (e, t = {}, l) {
          for (const n in t)
            if (Object.prototype.hasOwnProperty.call(t, n)) {
              const r = t[n],
                i = e.getRow(Number(n) + 1);
              (i.height = r.h ? ot(r.h) : l), (i.hidden = 1 === r.hd);
            }
        })(w, a.rowData, v),
        (function (e, t, l, n, r) {
          const { resources: i, sheets: a } = n,
            { cellData: s, id: o } = t;
          for (const t in s) {
            const n = s[t];
            for (const s in n) {
              const c = n[s];
              if (!c) continue;
              const u = e.getCell(Number(t) + 1, Number(s) + 1);
              u.value = yt(c, { resources: i, sheetId: o, rowId: t, columnId: s, sheets: a }, r);
              let h = c.s;
              'string' == typeof c.s && (h = l[c.s]);
              const f = ae(ht(h, h?.n?.pattern || c.f));
              Object.assign(u, f);
            }
          }
        })(w, a, r, t, e),
        (function (e, t) {
          t.forEach((t) => {
            e.mergeCells(t.startRow + 1, t.startColumn + 1, t.endRow + 1, t.endColumn + 1);
          });
        })(w, p),
        new pt(s, e, w, i);
    });
  }
  function yt(e, t, l) {
    const { sheets: n } = t,
      r = (function (e) {
        const { resources: t, sheetId: l, rowId: n, columnId: r } = e,
          i = re(t.find((e) => 'SHEET_HYPER_LINK_PLUGIN' === e.name)?.data);
        return (i?.[l] || []).find((e) => e.row === Number(n) && e.column === Number(r));
      })(t),
      i = (function (e, t) {
        let l;
        if (e) {
          const { payload: n } = e;
          let r = '',
            i = '';
          if (n.includes('#gid=') || n.includes('range=')) {
            const e = n.replace('#', '').split('&');
            (r += ''),
              1 === e.length && e[0].includes('range=') && (r += e[0].replace('range=')),
              2 === e.length &&
                ((r += `'${(function (e, t) {
                  return e[t]?.name;
                })(t, e[0].replace('gid=', ''))}'`),
                (r += `!${e[1].replace('range=', '')}`));
          } else (r = n), (i = 'External');
          r && (l = { hyperlink: r, hyperlinkModel: i });
        }
        return l;
      })(r, n);
    let a;
    if (e.p) {
      const t = e.p?.body;
      if (e.p.drawingsOrder?.length) {
        const t = e.p.drawings[e.p.drawingsOrder[0]],
          { id: n, value: r } = l.addCellImage({
            base64: t.source,
            extension: 'png',
            descr: t.description,
            ext: { width: t.transform.width, height: t.transform.height },
          });
        return (a = { id: n, cellImageId: r, ...(i || {}) }), a;
      }
      a = {
        richText: t?.textRuns.map((e) => ({
          text: t.dataStream.substring(e.st, e.ed),
          font: ft(e.ts),
        })),
      };
    } else a = e.si ? { formula: e.si, result: e.v } : e.v;
    if (i) {
      const e = a?.richText?.map?.((e) => e.text)?.join('') || a?.result || a;
      a = { text: e, ...i };
    }
    return a;
  }
  const vt = c.default.Workbook;
  class wt extends vt {
    constructor(e) {
      super(), this.init(e);
    }
    init(e) {
      (this.calcProperties.fullCalcOnLoad = !0), this.setDefineNames(e.resources), Tt(this, e);
    }
    setDefineNames(e) {
      const t = re(e.find((e) => 'SHEET_DEFINED_NAME_PLUGIN' === e.name)?.data);
      for (const e in t) {
        const l = t[e];
        this.definedNames.add(l.formulaOrRefString, l.name);
      }
    }
  }
  class It {
    constructor(e) {
      (this.csvList = {}), (this.csvContent = {}), this.init(e);
    }
    init(e) {
      if (!e) return;
      const { sheetOrder: t, sheets: l } = e,
        n = {};
      t.forEach((e) => {
        const t = l[e];
        if (!t) return;
        const { cellData: r, name: i } = t,
          a = [];
        for (const e in r) {
          const t = r[e];
          for (const e in t) {
            const l = Number(e),
              n = Number(e);
            a[l] || (a[l] = []), (a[l][n] = t[e]?.v);
          }
        }
        n[i] = a;
      }),
        (this.csvList = n),
        this.handleCsvContent();
    }
    handleCsvContent() {
      const e = {};
      for (const t in this.csvList) {
        const l = this.csvList[t];
        let n = 'data:text/csv;charset=utf-8,';
        l.forEach((e) => {
          n += e.join(',') + '\r\n';
        }),
          (e[t] = n);
      }
      this.csvContent = e;
    }
  }
  class Ct {
    constructor(e) {
      (this.type = l.SheetTypes.GRID),
        (this.tabColor = ''),
        (this.hidden = 0),
        (this.freeze = { xSplit: 0, ySplit: 0, startRow: -1, startColumn: -1 }),
        (this.rowCount = 100),
        (this.columnCount = 20),
        (this.zoomRatio = 1),
        (this.scrollTop = 0),
        (this.scrollLeft = 0),
        (this.defaultColumnWidth = 93),
        (this.defaultRowHeight = 27),
        (this.mergeData = []),
        (this.cellData = {}),
        (this.rowData = {}),
        (this.columnData = {}),
        (this.rowHeader = { width: 46, hidden: 0 }),
        (this.columnHeader = { height: 20, hidden: 0 }),
        (this.showGridlines = 1),
        (this.rightToLeft = 0),
        (this.selections = []);
      const { id: t, name: n, cellData: r, rowCount: i = 0, colCount: a = 0 } = e || {};
      (this.id = t || ''),
        (this.name = n || ''),
        (this.cellData = r || {}),
        (this.rowCount = Math.max(this.rowCount, i)),
        (this.columnCount = Math.max(this.columnCount, a));
    }
  }
  function Rt(e) {
    for (const t in e)
      Object.prototype.hasOwnProperty.call(e, t) &&
        (void 0 === e[t] ? delete e[t] : ie(e[t]) && null !== e[t] && Rt(e[t]));
    return e;
  }
  const Lt = (e, t, n = !1) => {
    const { v: r } = e;
    if ('string' == typeof r || null == r) return;
    const i = { 0: l.VerticalAlign.MIDDLE, 1: l.VerticalAlign.TOP, 2: l.VerticalAlign.BOTTOM };
    let a;
    if (t?.value && !n) {
      const e = (e) =>
        e ? { s: e.style, cl: { rgb: e.color, th: l.ThemeColorType.DARK1 } } : null;
      a = {
        t: e(t.value?.t),
        r: e(t.value?.r),
        b: e(t.value?.b),
        l: e(t.value?.l),
        bl_tr: e(t.value?.bl_tr),
        tl_br: e(t.value?.tl_br),
      };
    }
    const s = { 0: l.WrapStrategy.CLIP, 1: l.WrapStrategy.OVERFLOW, 2: l.WrapStrategy.WRAP };
    let o;
    r.tr && (o = { 1: 45, 2: 135, 3: 255, 4: 90, 5: 180 }[r.tr]), r.rt && (o = r.rt);
    const c = {
        0: l.TextDecoration.DASH,
        1: l.TextDecoration.SINGLE,
        2: l.TextDecoration.DOUBLE,
        3: l.TextDecoration.SINGLE,
        4: l.TextDecoration.DOUBLE,
      },
      u = { 0: l.HorizontalAlign.CENTER, 1: l.HorizontalAlign.LEFT, 2: l.HorizontalAlign.RIGHT };
    return {
      bd: a,
      bg: void 0 !== r.bg ? { rgb: r.bg, th: l.ThemeColorType.DARK1 } : void 0,
      bl: r.bl,
      cl: void 0 !== r.fc ? { rgb: r.fc, th: l.ThemeColorType.DARK1 } : void 0,
      ff: r.ff,
      fs: r.fs,
      ht: void 0 !== r.ht ? u[r.ht] : void 0,
      it: r.it,
      n: void 0 !== r.ct?.fa ? { pattern: r.ct.fa } : void 0,
      st:
        void 0 !== r.cl ? { s: 1 === r.cl ? l.BooleanNumber.TRUE : l.BooleanNumber.FALSE } : void 0,
      tb: void 0 !== r.tb ? s[r.tb] : void 0,
      tr:
        void 0 !== o
          ? { a: o, v: r.tr || r.rt ? l.BooleanNumber.TRUE : l.BooleanNumber.FALSE }
          : void 0,
      ul:
        void 0 !== r.un
          ? {
              s: void 0 === r.un ? l.BooleanNumber.FALSE : l.BooleanNumber.TRUE,
              t: r.un ? c[r.un] : l.TextDecoration.DASH,
            }
          : void 0,
      vt: void 0 !== r.vt ? i[r.vt] : void 0,
    };
  };
  var St, xt;
  !(function (e) {
    (e.URL = 'URL'), (e.UUID = 'UUID'), (e.BASE64 = 'BASE64');
  })(St || (St = {}));
  class Nt extends Ct {
    constructor(e) {
      super(),
        (this.hyperLink = []),
        (this.handleMerge = (e) => {
          const t = e.merge;
          return t
            ? Object.values(t).map((e) => ({
                startRow: e.r,
                endRow: e.r + e.rs - 1,
                startColumn: e.c,
                endColumn: e.c + e.cs - 1,
              }))
            : [];
        }),
        (this.handleCellData = (e, t) => {
          const n = (e) => {
            const { v: n } = e;
            if ('string' == typeof n || null == n) return { v: n };
            const r = {
                s: l.CellValueType.STRING,
                n: l.CellValueType.NUMBER,
                b: l.CellValueType.BOOLEAN,
                str: l.CellValueType.STRING,
              },
              i = t.borderInfo?.find((t) => t.value.col_index === e.c && t.value.row_index === e.r);
            let a = n.ct?.t && r[n.ct?.t] ? r[n.ct?.t] : l.CellValueType.NUMBER,
              s = a === l.CellValueType.NUMBER ? le(n.v) : n.v;
            a === l.CellValueType.BOOLEAN && (s = '1' == n.v ? 1 : 0),
              Number.isNaN(Number(s)) &&
                a === l.CellValueType.NUMBER &&
                (a = l.CellValueType.STRING),
              this.hyperLink.findIndex((t) => t.column === e.c && t.row === e.r) > -1 &&
                (a = l.CellValueType.STRING);
            const o = n.f?.replace(/=_xlfn./g, '='),
              c = { f: o, s: Lt(e, i), t: a, v: s },
              u = this.handleDocument(e, t);
            u && (c.p = u);
            const h = this.handleCellImage(e, t);
            return h && ((c.p = h), (c.f = void 0), (c.v = void 0)), Rt(c);
          };
          let r,
            i = 0;
          const a = e.reduce(
              (e, t) => (
                r === t.r ? e[t.r].push(t) : ((r = t.r), (e[r] = [t])), t.c > i && (i = t.c), e
              ),
              [],
            ),
            s = {};
          return (
            a.forEach((e, t) => {
              for (let l = 0; l < i + 1; l++) {
                const r = e.find((e) => e.c === l) || { r: t, c: l, v: null };
                s[r.r] || (s[r.r] = {}), (s[r.r][r.c] = n(r));
              }
            }),
            { cellData: s, rowCount: a.length, colCount: i }
          );
        }),
        (this.handleDocument = (e, t) => {
          const l = (e, t) => {
            const l = new RegExp(t, 'g');
            let n;
            const r = [];
            for (; (n = l.exec(e)); ) r.push(n.index);
            return r;
          };
          let n = null;
          const { v: r } = e;
          if ('string' != typeof r && null != r) {
            if (r.ct && 'inlineStr' === r.ct.t) {
              r.ct.s = r.ct.s.map(
                (e) => (
                  (e.v = ((e, t) => {
                    const l = new RegExp(`${t}`, 'g');
                    return e.replace(l, '\r');
                  })(e.v || '', '\r\n')),
                  e
                ),
              );
              let i = r.ct.s.reduce((e, t) => e + t.v, '');
              i = i?.replace(/\n/g, '\r') + '\r\n';
              const a = {
                  r: '\r',
                  n: '\n',
                  v: '\v',
                  f: '\f',
                  0: '\0',
                  t: '\t',
                  b: '\b',
                  x1A: '',
                  x1B: '',
                  x1C: '',
                  x1D: '',
                  x1E: '',
                  x1F: '',
                },
                s = l(i, a.r).map((e) => ({ startIndex: e })),
                o = l(i, a.n).map((e) => ({ startIndex: e })),
                c = r.ct.s?.map((l, n) => {
                  const i = r.ct.s?.reduce((e, t, l) => (l < n ? e + (t.v?.length || 0) : e), 0),
                    a = i + (r.ct.s?.[n]?.v?.length || 0),
                    s = t.borderInfo?.find(
                      (t) => t.value.col_index === e.c && t.value.row_index === e.r,
                    );
                  return {
                    st: i,
                    ed: a,
                    ts: Lt({ v: r.ct.s[n] || r.ct.s[0], r: e.r, c: e.c }, s, !0),
                  };
                });
              n = {
                id: ne(6),
                documentStyle: {
                  documentFlavor: 0,
                  pageSize: { width: 0, height: 0 },
                  renderConfig: {},
                  textStyle: {},
                },
                body: { dataStream: i, paragraphs: s, sectionBreaks: o, textRuns: c },
                drawings: {},
              };
            }
            return n;
          }
        }),
        (this.handleCellImage = (e, t) => {
          let n = null;
          const { v: r } = e;
          if ('string' != typeof r && null != r) {
            if (r.ct && 'str' === r.ct.t && r.ct.ci) {
              const i = ne(6),
                a = ne(6),
                { default: s, src: o, descr: c } = r.ct.ci || {},
                u = t.borderInfo?.find(
                  (t) => t.value.col_index === e.c && t.value.row_index === e.r,
                );
              n = {
                id: a,
                documentStyle: {
                  documentFlavor: 0,
                  pageSize: { width: 0, height: 0 },
                  renderConfig: {},
                  textStyle: {},
                },
                body: {
                  dataStream: '\b\r\n',
                  paragraphs: [{ startIndex: 1, paragraphStyle: { horizontalAlign: r.ht } }],
                  sectionBreaks: [{ startIndex: 2 }],
                  textRuns: [{ ed: 1, st: 0, ts: Lt({ v: r, r: e.r, c: e.c }, u, !0) }],
                  customBlocks: [{ startIndex: 0, blockId: i }],
                },
                drawings: {
                  [i]: {
                    unitId: a,
                    subUnitId: a,
                    drawingId: i,
                    layoutType: l.PositionedObjectLayoutType.INLINE,
                    title: '',
                    description: c,
                    docTransform: {
                      size: { width: s.width, height: s.height },
                      positionH: { relativeFrom: 0, posOffset: 0 },
                      positionV: { relativeFrom: 1, posOffset: 0 },
                      angle: 0,
                    },
                    drawingType: l.DrawingTypeEnum.DRAWING_IMAGE,
                    imageSourceType: St.BASE64,
                    source: o,
                    transform: s,
                  },
                },
                drawingsOrder: [i],
              };
            }
            return n;
          }
        }),
        (this.handleRowAndColumnData = (e) => {
          const t = {},
            n = {};
          for (let t = 0; t < this.rowCount; t++)
            n[t] = {
              h: e.rowlen?.[t] || this.defaultRowHeight,
              ia: e.rowlen?.[t] ? l.BooleanNumber.FALSE : l.BooleanNumber.TRUE,
              ah: this.defaultRowHeight,
              hd: 0 === e.rowhidden?.[t] ? l.BooleanNumber.TRUE : l.BooleanNumber.FALSE,
            };
          for (let n = 0; n < this.columnCount; n++)
            t[n] = {
              w: e.columnlen?.[n] || this.defaultColumnWidth,
              hd: 0 === e.colhidden?.[n] ? l.BooleanNumber.TRUE : l.BooleanNumber.FALSE,
            };
          (this.rowData = n), (this.columnData = t);
        }),
        (this.handleSheetLink = (e) => {
          if (!e) return;
          const t = Object.keys(e).map((t) => {
            const l = t.split('_')[0],
              n = t.split('_')[1],
              r = e[t];
            let i = r.linkAddress;
            if ('internal' === r.linkType) {
              const e = r.linkAddress.split('!');
              (i = {}), e[0] && (i.gid = e[0]), e[1] && (i.range = e[1]);
            }
            return { id: ne(6), row: Number(l), column: Number(n), payload: i };
          });
          this.hyperLink = t;
        }),
        (this.handleFreeze = (e) => {
          this.freeze = {
            xSplit: e.vertical,
            ySplit: e.horizen,
            startColumn: e.vertical,
            startRow: e.horizen,
          };
        });
      const {
        color: t,
        zoomRatio: n,
        celldata: r,
        config: i = {},
        showGridLines: a,
        defaultColWidth: s,
        defaultRowHeight: o,
        hide: c,
      } = e || {};
      if (((this.name = e.name), (this.id = `sheet-${e.index}`), e)) {
        if (
          ((this.tabColor = t),
          (this.zoomRatio = n),
          (this.showGridlines = Number(a)),
          (this.defaultColumnWidth = s),
          (this.defaultRowHeight = o),
          (this.hidden = c),
          this.handleSheetLink(e.hyperlink),
          i.merge && (this.mergeData = this.handleMerge(i)),
          r?.length)
        ) {
          const { cellData: e, rowCount: t, colCount: l } = this.handleCellData(r, i);
          (this.cellData = e),
            (this.rowCount = this.rowCount > t ? this.rowCount : t + 1),
            (this.columnCount = this.columnCount > l ? this.columnCount : l + 1);
        }
        console.log(this.rowCount, this.columnCount),
          this.handleRowAndColumnData(i),
          e.freezen && this.handleFreeze(e.freezen);
      }
    }
    get mode() {
      return {
        id: this.id,
        name: this.name,
        type: this.type,
        tabColor: this.tabColor,
        hidden: this.hidden,
        freeze: this.freeze,
        rowCount: this.rowCount,
        columnCount: this.columnCount,
        zoomRatio: this.zoomRatio,
        scrollTop: this.scrollTop,
        scrollLeft: this.scrollLeft,
        defaultColumnWidth: this.defaultColumnWidth,
        defaultRowHeight: this.defaultRowHeight,
        mergeData: this.mergeData,
        cellData: this.cellData,
        rowData: this.rowData,
        columnData: this.columnData,
        rowHeader: this.rowHeader,
        columnHeader: this.columnHeader,
        showGridlines: this.showGridlines,
        rightToLeft: this.rightToLeft,
        selections: this.selections,
        hyperLink: this.hyperLink,
      };
    }
  }
  class Ot {
    constructor(e) {
      (this.resources = []),
        (this.handleHyperLinks = (e) => {
          const t = {};
          for (const l in e) {
            const n = e[l].hyperLink;
            n?.length &&
              (t[l] = n.map((t) => {
                let l = t.payload;
                if ('string' != typeof t.payload) {
                  l = '#';
                  const n = t.payload.gid.replace(/'|"/g, ''),
                    r = Object.values(e).find((e) => e.name === n)?.id;
                  n && r && (l += `gid=${r}`),
                    n && r && t.payload.range && (l += '&'),
                    t.payload.range && (l += `range=${t.payload.range}`);
                }
                return { ...t, payload: l };
              }));
          }
          this.resources?.push({ name: 'SHEET_HYPER_LINK_PLUGIN', data: JSON.stringify(t) });
        }),
        (this.handleImage = (e, t) => {
          const n = {};
          Object.values(e).forEach((e) => {
            const r = t.find((t) => t.name === e.name)?.images;
            if (!r) return;
            const i = Object.keys(r),
              a = {};
            i.forEach((t) => {
              const n = r[t];
              e.columnCount < n.toCol && (e.columnCount = n.toCol + 1),
                e.rowCount < n.toRow && (e.rowCount = n.toRow + 1);
              let i = {
                unitId: this.id,
                subUnitId: e.id || '',
                drawingId: t,
                transform: {
                  width: 0,
                  height: 0,
                  scaleX: 0,
                  scaleY: 0,
                  left: 0,
                  top: 0,
                  angle: 0,
                  skewX: 0,
                  skewY: 0,
                  flipX: !1,
                  flipY: !1,
                  ...(n.transform || {}),
                },
                sheetTransform: {
                  angle: 0,
                  skewX: 0,
                  skewY: 0,
                  flipX: !1,
                  flipY: !1,
                  from: {
                    column: n.fromCol,
                    columnOffset: n.fromColOff,
                    row: n.fromRow,
                    rowOffset: n.fromRowOff,
                  },
                  to: {
                    column: n.toCol,
                    columnOffset: n.toColOff,
                    row: n.toRow,
                    rowOffset: n.toRowOff,
                  },
                },
              };
              (i =
                'chart' === n.type
                  ? {
                      ...i,
                      drawingType: l.DrawingTypeEnum.DRAWING_CHART,
                      componentKey: 'Chart',
                      data: { ...(n.data || {}), range: `${e.name}!${n.data.range}` },
                      allowTransform: !0,
                    }
                  : {
                      ...i,
                      drawingType: l.DrawingTypeEnum.DRAWING_IMAGE,
                      imageSourceType: St.BASE64,
                      source: n.src,
                      prstGeom: 'rect',
                      anchorType: '1',
                    }),
                (a[t] = i);
            }),
              (n[e.id] = { data: a, order: i });
          }),
            this.resources?.push({ name: 'SHEET_DRAWING_PLUGIN', data: JSON.stringify(n) });
        }),
        (this.handleChart = (e, t) => {
          const l = {};
          Object.values(e).forEach((e) => {
            const n = t.find((t) => t.name === e.name)?.charts;
            n &&
              n.forEach((t) => {
                l[e.id] || (l[e.id] = []),
                  l[e.id].push({
                    rangeInfo: {
                      isRowDirection: t.isRowDirection,
                      rangeInfo: { unitId: this.id, subUnitId: e.id || '', range: Pe(t.range)[0] },
                    },
                    id: t.id,
                    chartType: t.chartType,
                    context: t.context,
                    style: t.style,
                    dataAggregation: {},
                  });
              });
          }),
            this.resources?.push({ name: 'SHEET_CHART_PLUGIN', data: JSON.stringify(l) });
        }),
        (this.handleNames = (e) => {
          this.resources?.push({
            name: 'SHEET_DEFINED_NAME_PLUGIN',
            data: JSON.stringify(e.defineNames),
          });
        }),
        (this.handleCondition = (e) => {
          const t = {};
          Object.keys(e).forEach((l) => {
            const n = e[l].conditionalFormatting?.map(
              (e) => (
                e.rule?.style &&
                  (e.rule.style = Lt(
                    { v: e.rule.style, r: 0, c: 0 },
                    { value: e.rule?.style?.border, rangeType: '' },
                  )),
                e
              ),
            );
            t[l] = n;
          }),
            this.resources?.push({
              name: 'SHEET_CONDITIONAL_FORMATTING_PLUGIN',
              data: JSON.stringify(t),
            });
        }),
        (this.handleVerification = (e) => {
          const t = {};
          Object.keys(e).forEach((l) => {
            t[l] = e[l].dataVerificationList;
          }),
            this.resources?.push({ name: 'SHEET_DATA_VALIDATION_PLUGIN', data: JSON.stringify(t) });
        }),
        (this.handleFilter = (e) => {
          const t = {};
          Object.keys(e).forEach((l) => {
            t[l] = e[l].filter;
          }),
            this.resources?.push({ name: 'SHEET_FILTER_PLUGIN', data: JSON.stringify(t) });
        });
      const { info: t, sheets: n, workbook: r } = e;
      (this.id = ne(6)),
        (this.name = t.name),
        (this.appVersion = t.appversion),
        (this.locale = l.LocaleType.ZH_CN);
      const i = {},
        a = [],
        s = {};
      n
        .sort((e, t) => Number(e.order) - Number(t.order))
        .forEach((e) => {
          const t = new Nt(e);
          (i[t.id] = t.mode), (s[t.id] = e), a.push(t.id);
        }),
        this.handleHyperLinks(i),
        this.handleImage(i, n),
        this.handleChart(i, n),
        this.handleNames(r),
        this.handleCondition(s),
        this.handleVerification(s),
        this.handleFilter(s),
        (this.sheetOrder = a),
        (this.sheets = i);
    }
    get mode() {
      return {
        id: this.id,
        rev: this.rev,
        name: this.name,
        appVersion: this.appVersion,
        locale: this.locale,
        styles: this.styles,
        sheetOrder: this.sheetOrder,
        sheets: this.sheets,
        resources: this.resources,
      };
    }
  }
  !(function (e) {
    (e.UTF8 = 'UTF-8'), (e.GBK = 'GBK'), (e.CP936 = 'CP936'), (e.ISO8859 = 'ISO-8859');
  })(xt || (xt = {}));
  class Mt {
    constructor(e) {
      console.log(e);
      const t = {};
      let l = 0,
        n = 0;
      e.forEach((e, r) => {
        r + 1 > l && (l = r + 1),
          e.forEach((e, l) => {
            l + 1 > n && (n = l + 1), t[r] || (t[r] = {}), (t[r][l] = { v: e || '' });
          });
      });
      const r = 'sheet1',
        i = new Ct({ id: r, name: r, cellData: t, rowCount: l, colCount: n });
      (this.sheets = { [r]: i }), (this.sheetOrder = [r]), (this.id = ne(6)), (this.name = this.id);
    }
    get mode() {
      return {
        id: this.id,
        rev: this.rev,
        name: this.name,
        appVersion: this.appVersion,
        locale: this.locale,
        styles: this.styles,
        sheetOrder: this.sheetOrder,
        sheets: this.sheets,
        resources: this.resources,
      };
    }
  }
  return class {
    constructor() {}
    static transformExcelToLucky(e, t, l) {
      new it(e).unzipFile(
        function (l) {
          let n = new rt(l, e.name).Parse(),
            r = JSON.parse(n);
          null != t && t(r, n);
        },
        function (e) {
          l ? l(e) : console.error(e);
        },
      );
    }
    static transformExcelToLuckyByUrl(e, t, l, n) {
      new it().unzipFileByUrl(
        e,
        function (e) {
          let n = new rt(e, t).Parse(),
            r = JSON.parse(n);
          null != l && l(r, n);
        },
        function (e) {
          n ? n(e) : console.error(e);
        },
      );
    }
    static transformExcelToUniver(e, t, l) {
      new it(e).unzipFile(
        function (l) {
          let n = new rt(l, e.name).Parse(),
            r = JSON.parse(n);
          if ((console.log('output----\x3e', r, l), null != t)) {
            const e = new Ot(r);
            t(e.mode, n);
          }
        },
        function (e) {
          l ? l(e) : console.error(e);
        },
      );
    }
    static transformCsvToUniver(e, t, l) {
      try {
        (({ file: e, charset: t = xt.UTF8 }) =>
          new Promise((l, n) => {
            e instanceof File || l('');
            const r = new FileReader();
            (r.onload = (e) => {
              try {
                const { result: t } = e.target;
                l(t);
              } catch (e) {
                n(e);
              }
            }),
              r.readAsText(e, t);
          }))({ file: e }).then((l) => {
          const n = ((e, t) => {
              const l = e.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
              let n = [];
              if (t.name.endsWith('.csv') || 'text/csv' === t.type)
                n = u.default.parse(e, { delimiter: ',', skipEmptyLines: !0 }).data;
              else
                for (let e = 0; e < l.length; e++) {
                  const t = l[e].replace(/\r/, '');
                  t && n.push(t.split(','));
                }
              return n;
            })(l, e),
            r = new Mt(n || []);
          t?.(r.mode, n);
        });
      } catch (e) {
        l(e);
      }
    }
    static async transformUniverToExcel(e) {
      const {
        snapshot: t,
        fileName: l = `excel_${new Date().getTime()}.xlsx`,
        getBuffer: n = !1,
        success: r,
        error: i,
      } = e;
      try {
        const e = new wt(t),
          i = await e.xlsx.writeBuffer();
        n ? r?.(i) : (this.downloadFile(l, i), r?.());
      } catch (e) {
        i?.(e);
      }
    }
    static async transformUniverToCsv(e) {
      const {
        snapshot: t,
        fileName: l = `csv_${new Date().getTime()}.csv`,
        getBuffer: n = !1,
        success: r,
        error: i,
        sheetName: a,
      } = e;
      try {
        const e = new It(t);
        let i;
        if ((console.log(e), (i = a ? e.csvContent[a] : e.csvContent), n)) r?.(i);
        else {
          if (ie(i)) {
            for (const e in i)
              if (Object.prototype.hasOwnProperty.call(i, e)) {
                const t = i[e];
                this.downloadFile(`${l}_${e}`, t);
              }
          } else this.downloadFile(l, i);
          r?.();
        }
      } catch (e) {
        i(e);
      }
    }
    static downloadFile(e, t) {
      const l = document.createElement('a');
      let n;
      n =
        'string' == typeof t
          ? new Blob([t], { type: 'text/csv;charset=utf-8;' })
          : new Blob([t], {
              type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8',
            });
      const r = URL.createObjectURL(n);
      (l.href = r),
        (l.download = e),
        document.body.appendChild(l),
        l.click(),
        l.addEventListener('click', () => {
          l.remove(),
            setTimeout(() => {
              URL.revokeObjectURL(r);
            }, 200);
        });
    }
  };
});
//# sourceMappingURL=/sm/6f348b11ba01aef9119b0cb09caeb5b264073a974178490a28c714757b4c1f87.map
